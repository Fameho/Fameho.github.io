<!doctype html>
<html>
<head>
<meta charset='UTF-8'><meta name='viewport' content='width=device-width initial-scale=1'>

<link href='https://fonts.loli.net/css?family=Open+Sans:400italic,700italic,700,400&subset=latin,latin-ext' rel='stylesheet' type='text/css' /><style type='text/css'>html {overflow-x: initial !important;}:root { --bg-color:#ffffff; --text-color:#333333; --select-text-bg-color:#B5D6FC; --select-text-font-color:auto; --monospace:"Lucida Console",Consolas,"Courier",monospace; --title-bar-height:20px; }
.mac-os-11 { --title-bar-height:28px; }
html { font-size: 14px; background-color: var(--bg-color); color: var(--text-color); font-family: "Helvetica Neue", Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; }
body { margin: 0px; padding: 0px; height: auto; inset: 0px; font-size: 1rem; line-height: 1.42857; overflow-x: hidden; background: inherit; tab-size: 4; }
iframe { margin: auto; }
a.url { word-break: break-all; }
a:active, a:hover { outline: 0px; }
.in-text-selection, ::selection { text-shadow: none; background: var(--select-text-bg-color); color: var(--select-text-font-color); }
#write { margin: 0px auto; height: auto; width: inherit; word-break: normal; overflow-wrap: break-word; position: relative; white-space: normal; overflow-x: visible; padding-top: 36px; }
#write.first-line-indent p { text-indent: 2em; }
#write.first-line-indent li p, #write.first-line-indent p * { text-indent: 0px; }
#write.first-line-indent li { margin-left: 2em; }
.for-image #write { padding-left: 8px; padding-right: 8px; }
body.typora-export { padding-left: 30px; padding-right: 30px; }
.typora-export .footnote-line, .typora-export li, .typora-export p { white-space: pre-wrap; }
.typora-export .task-list-item input { pointer-events: none; }
@media screen and (max-width: 500px) {
  body.typora-export { padding-left: 0px; padding-right: 0px; }
  #write { padding-left: 20px; padding-right: 20px; }
  .CodeMirror-sizer { margin-left: 0px !important; }
  .CodeMirror-gutters { display: none !important; }
}
#write li > figure:last-child { margin-bottom: 0.5rem; }
#write ol, #write ul { position: relative; }
img { max-width: 100%; vertical-align: middle; image-orientation: from-image; }
button, input, select, textarea { color: inherit; font: inherit; }
input[type="checkbox"], input[type="radio"] { line-height: normal; padding: 0px; }
*, ::after, ::before { box-sizing: border-box; }
#write h1, #write h2, #write h3, #write h4, #write h5, #write h6, #write p, #write pre { width: inherit; }
#write h1, #write h2, #write h3, #write h4, #write h5, #write h6, #write p { position: relative; }
p { line-height: inherit; }
h1, h2, h3, h4, h5, h6 { break-after: avoid-page; break-inside: avoid; orphans: 4; }
p { orphans: 4; }
h1 { font-size: 2rem; }
h2 { font-size: 1.8rem; }
h3 { font-size: 1.6rem; }
h4 { font-size: 1.4rem; }
h5 { font-size: 1.2rem; }
h6 { font-size: 1rem; }
.md-math-block, .md-rawblock, h1, h2, h3, h4, h5, h6, p { margin-top: 1rem; margin-bottom: 1rem; }
.hidden { display: none; }
.md-blockmeta { color: rgb(204, 204, 204); font-weight: 700; font-style: italic; }
a { cursor: pointer; }
sup.md-footnote { padding: 2px 4px; background-color: rgba(238, 238, 238, 0.7); color: rgb(85, 85, 85); border-radius: 4px; cursor: pointer; }
sup.md-footnote a, sup.md-footnote a:hover { color: inherit; text-transform: inherit; text-decoration: inherit; }
#write input[type="checkbox"] { cursor: pointer; width: inherit; height: inherit; }
figure { overflow-x: auto; margin: 1.2em 0px; max-width: calc(100% + 16px); padding: 0px; }
figure > table { margin: 0px; }
tr { break-inside: avoid; break-after: auto; }
thead { display: table-header-group; }
table { border-collapse: collapse; border-spacing: 0px; width: 100%; overflow: auto; break-inside: auto; text-align: left; }
table.md-table td { min-width: 32px; }
.CodeMirror-gutters { border-right: 0px; background-color: inherit; }
.CodeMirror-linenumber { user-select: none; }
.CodeMirror { text-align: left; }
.CodeMirror-placeholder { opacity: 0.3; }
.CodeMirror pre { padding: 0px 4px; }
.CodeMirror-lines { padding: 0px; }
div.hr:focus { cursor: none; }
#write pre { white-space: pre-wrap; }
#write.fences-no-line-wrapping pre { white-space: pre; }
#write pre.ty-contain-cm { white-space: normal; }
.CodeMirror-gutters { margin-right: 4px; }
.md-fences { font-size: 0.9rem; display: block; break-inside: avoid; text-align: left; overflow: visible; white-space: pre; background: inherit; position: relative !important; }
.md-fences-adv-panel { width: 100%; margin-top: 10px; text-align: center; padding-top: 0px; padding-bottom: 8px; overflow-x: auto; }
#write .md-fences.mock-cm { white-space: pre-wrap; }
.md-fences.md-fences-with-lineno { padding-left: 0px; }
#write.fences-no-line-wrapping .md-fences.mock-cm { white-space: pre; overflow-x: auto; }
.md-fences.mock-cm.md-fences-with-lineno { padding-left: 8px; }
.CodeMirror-line, twitterwidget { break-inside: avoid; }
.footnotes { opacity: 0.8; font-size: 0.9rem; margin-top: 1em; margin-bottom: 1em; }
.footnotes + .footnotes { margin-top: 0px; }
.md-reset { margin: 0px; padding: 0px; border: 0px; outline: 0px; vertical-align: top; background: 0px 0px; text-decoration: none; text-shadow: none; float: none; position: static; width: auto; height: auto; white-space: nowrap; cursor: inherit; -webkit-tap-highlight-color: transparent; line-height: normal; font-weight: 400; text-align: left; box-sizing: content-box; direction: ltr; }
li div { padding-top: 0px; }
blockquote { margin: 1rem 0px; }
li .mathjax-block, li p { margin: 0.5rem 0px; }
li blockquote { margin: 1rem 0px; }
li { margin: 0px; position: relative; }
blockquote > :last-child { margin-bottom: 0px; }
blockquote > :first-child, li > :first-child { margin-top: 0px; }
.footnotes-area { color: rgb(136, 136, 136); margin-top: 0.714rem; padding-bottom: 0.143rem; white-space: normal; }
#write .footnote-line { white-space: pre-wrap; }
@media print {
  body, html { border: 1px solid transparent; height: 99%; break-after: avoid; break-before: avoid; font-variant-ligatures: no-common-ligatures; }
  #write { margin-top: 0px; padding-top: 0px; border-color: transparent !important; }
  .typora-export * { -webkit-print-color-adjust: exact; }
  .typora-export #write { break-after: avoid; }
  .typora-export #write::after { height: 0px; }
  .is-mac table { break-inside: avoid; }
  .typora-export-show-outline .typora-export-sidebar { display: none; }
}
.footnote-line { margin-top: 0.714em; font-size: 0.7em; }
a img, img a { cursor: pointer; }
pre.md-meta-block { font-size: 0.8rem; min-height: 0.8rem; white-space: pre-wrap; background: rgb(204, 204, 204); display: block; overflow-x: hidden; }
p > .md-image:only-child:not(.md-img-error) img, p > img:only-child { display: block; margin: auto; }
#write.first-line-indent p > .md-image:only-child:not(.md-img-error) img { left: -2em; position: relative; }
p > .md-image:only-child { display: inline-block; width: 100%; }
#write .MathJax_Display { margin: 0.8em 0px 0px; }
.md-math-block { width: 100%; }
.md-math-block:not(:empty)::after { display: none; }
.MathJax_ref { fill: currentcolor; }
[contenteditable="true"]:active, [contenteditable="true"]:focus, [contenteditable="false"]:active, [contenteditable="false"]:focus { outline: 0px; box-shadow: none; }
.md-task-list-item { position: relative; list-style-type: none; }
.task-list-item.md-task-list-item { padding-left: 0px; }
.md-task-list-item > input { position: absolute; top: 0px; left: 0px; margin-left: -1.2em; margin-top: calc(1em - 10px); border: none; }
.math { font-size: 1rem; }
.md-toc { min-height: 3.58rem; position: relative; font-size: 0.9rem; border-radius: 10px; }
.md-toc-content { position: relative; margin-left: 0px; }
.md-toc-content::after, .md-toc::after { display: none; }
.md-toc-item { display: block; color: rgb(65, 131, 196); }
.md-toc-item a { text-decoration: none; }
.md-toc-inner:hover { text-decoration: underline; }
.md-toc-inner { display: inline-block; cursor: pointer; }
.md-toc-h1 .md-toc-inner { margin-left: 0px; font-weight: 700; }
.md-toc-h2 .md-toc-inner { margin-left: 2em; }
.md-toc-h3 .md-toc-inner { margin-left: 4em; }
.md-toc-h4 .md-toc-inner { margin-left: 6em; }
.md-toc-h5 .md-toc-inner { margin-left: 8em; }
.md-toc-h6 .md-toc-inner { margin-left: 10em; }
@media screen and (max-width: 48em) {
  .md-toc-h3 .md-toc-inner { margin-left: 3.5em; }
  .md-toc-h4 .md-toc-inner { margin-left: 5em; }
  .md-toc-h5 .md-toc-inner { margin-left: 6.5em; }
  .md-toc-h6 .md-toc-inner { margin-left: 8em; }
}
a.md-toc-inner { font-size: inherit; font-style: inherit; font-weight: inherit; line-height: inherit; }
.footnote-line a:not(.reversefootnote) { color: inherit; }
.md-attr { display: none; }
.md-fn-count::after { content: "."; }
code, pre, samp, tt { font-family: var(--monospace); }
kbd { margin: 0px 0.1em; padding: 0.1em 0.6em; font-size: 0.8em; color: rgb(36, 39, 41); background: rgb(255, 255, 255); border: 1px solid rgb(173, 179, 185); border-radius: 3px; box-shadow: rgba(12, 13, 14, 0.2) 0px 1px 0px, rgb(255, 255, 255) 0px 0px 0px 2px inset; white-space: nowrap; vertical-align: middle; }
.md-comment { color: rgb(162, 127, 3); opacity: 0.6; font-family: var(--monospace); }
code { text-align: left; vertical-align: initial; }
a.md-print-anchor { white-space: pre !important; border-width: initial !important; border-style: none !important; border-color: initial !important; display: inline-block !important; position: absolute !important; width: 1px !important; right: 0px !important; outline: 0px !important; background: 0px 0px !important; text-decoration: initial !important; text-shadow: initial !important; }
.os-windows.monocolor-emoji .md-emoji { font-family: "Segoe UI Symbol", sans-serif; }
.md-diagram-panel > svg { max-width: 100%; }
[lang="flow"] svg, [lang="mermaid"] svg { max-width: 100%; height: auto; }
[lang="mermaid"] .node text { font-size: 1rem; }
table tr th { border-bottom: 0px; }
video { max-width: 100%; display: block; margin: 0px auto; }
iframe { max-width: 100%; width: 100%; border: none; }
.highlight td, .highlight tr { border: 0px; }
mark { background: rgb(255, 255, 0); color: rgb(0, 0, 0); }
.md-html-inline .md-plain, .md-html-inline strong, mark .md-inline-math, mark strong { color: inherit; }
.md-expand mark .md-meta { opacity: 0.3 !important; }
mark .md-meta { color: rgb(0, 0, 0); }
@media print {
  .typora-export h1, .typora-export h2, .typora-export h3, .typora-export h4, .typora-export h5, .typora-export h6 { break-inside: avoid; }
}
.md-diagram-panel .messageText { stroke: none !important; }
.md-diagram-panel .start-state { fill: var(--node-fill); }
.md-diagram-panel .edgeLabel rect { opacity: 1 !important; }
.md-fences.md-fences-math { font-size: 1em; }
.md-fences-advanced:not(.md-focus) { padding: 0px; white-space: nowrap; border: 0px; }
.md-fences-advanced:not(.md-focus) { background: inherit; }
.typora-export-show-outline .typora-export-content { max-width: 1440px; margin: auto; display: flex; flex-direction: row; }
.typora-export-sidebar { width: 300px; font-size: 0.8rem; margin-top: 80px; margin-right: 18px; }
.typora-export-show-outline #write { --webkit-flex:2; flex: 2 1 0%; }
.typora-export-sidebar .outline-content { position: fixed; top: 0px; max-height: 100%; overflow: hidden auto; padding-bottom: 30px; padding-top: 60px; width: 300px; }
@media screen and (max-width: 1024px) {
  .typora-export-sidebar, .typora-export-sidebar .outline-content { width: 240px; }
}
@media screen and (max-width: 800px) {
  .typora-export-sidebar { display: none; }
}
.outline-content li, .outline-content ul { margin-left: 0px; margin-right: 0px; padding-left: 0px; padding-right: 0px; list-style: none; }
.outline-content ul { margin-top: 0px; margin-bottom: 0px; }
.outline-content strong { font-weight: 400; }
.outline-expander { width: 1rem; height: 1.42857rem; position: relative; display: table-cell; vertical-align: middle; cursor: pointer; padding-left: 4px; }
.outline-expander::before { content: ""; position: relative; font-family: Ionicons; display: inline-block; font-size: 8px; vertical-align: middle; }
.outline-item { padding-top: 3px; padding-bottom: 3px; cursor: pointer; }
.outline-expander:hover::before { content: ""; }
.outline-h1 > .outline-item { padding-left: 0px; }
.outline-h2 > .outline-item { padding-left: 1em; }
.outline-h3 > .outline-item { padding-left: 2em; }
.outline-h4 > .outline-item { padding-left: 3em; }
.outline-h5 > .outline-item { padding-left: 4em; }
.outline-h6 > .outline-item { padding-left: 5em; }
.outline-label { cursor: pointer; display: table-cell; vertical-align: middle; text-decoration: none; color: inherit; }
.outline-label:hover { text-decoration: underline; }
.outline-item:hover { border-color: rgb(245, 245, 245); background-color: var(--item-hover-bg-color); }
.outline-item:hover { margin-left: -28px; margin-right: -28px; border-left: 28px solid transparent; border-right: 28px solid transparent; }
.outline-item-single .outline-expander::before, .outline-item-single .outline-expander:hover::before { display: none; }
.outline-item-open > .outline-item > .outline-expander::before { content: ""; }
.outline-children { display: none; }
.info-panel-tab-wrapper { display: none; }
.outline-item-open > .outline-children { display: block; }
.typora-export .outline-item { padding-top: 1px; padding-bottom: 1px; }
.typora-export .outline-item:hover { margin-right: -8px; border-right: 8px solid transparent; }
.typora-export .outline-expander::before { content: "+"; font-family: inherit; top: -1px; }
.typora-export .outline-expander:hover::before, .typora-export .outline-item-open > .outline-item > .outline-expander::before { content: "−"; }
.typora-export-collapse-outline .outline-children { display: none; }
.typora-export-collapse-outline .outline-item-open > .outline-children, .typora-export-no-collapse-outline .outline-children { display: block; }
.typora-export-no-collapse-outline .outline-expander::before { content: "" !important; }
.typora-export-show-outline .outline-item-active > .outline-item .outline-label { font-weight: 700; }
.md-inline-math-container mjx-container { zoom: 0.95; }


:root {
    --side-bar-bg-color: #fafafa;
    --control-text-color: #777;
}

@include-when-export url(https://fonts.loli.net/css?family=Open+Sans:400italic,700italic,700,400&subset=latin,latin-ext);

/* open-sans-regular - latin-ext_latin */
  /* open-sans-italic - latin-ext_latin */
    /* open-sans-700 - latin-ext_latin */
    /* open-sans-700italic - latin-ext_latin */
  html {
    font-size: 16px;
    -webkit-font-smoothing: antialiased;
}

body {
    font-family: "Open Sans","Clear Sans", "Helvetica Neue", Helvetica, Arial, 'Segoe UI Emoji', sans-serif;
    color: rgb(51, 51, 51);
    line-height: 1.6;
}

#write {
    max-width: 860px;
  	margin: 0 auto;
  	padding: 30px;
    padding-bottom: 100px;
}

@media only screen and (min-width: 1400px) {
	#write {
		max-width: 1024px;
	}
}

@media only screen and (min-width: 1800px) {
	#write {
		max-width: 1200px;
	}
}

#write > ul:first-child,
#write > ol:first-child{
    margin-top: 30px;
}

a {
    color: #4183C4;
}
h1,
h2,
h3,
h4,
h5,
h6 {
    position: relative;
    margin-top: 1rem;
    margin-bottom: 1rem;
    font-weight: bold;
    line-height: 1.4;
    cursor: text;
}
h1:hover a.anchor,
h2:hover a.anchor,
h3:hover a.anchor,
h4:hover a.anchor,
h5:hover a.anchor,
h6:hover a.anchor {
    text-decoration: none;
}
h1 tt,
h1 code {
    font-size: inherit;
}
h2 tt,
h2 code {
    font-size: inherit;
}
h3 tt,
h3 code {
    font-size: inherit;
}
h4 tt,
h4 code {
    font-size: inherit;
}
h5 tt,
h5 code {
    font-size: inherit;
}
h6 tt,
h6 code {
    font-size: inherit;
}
h1 {
    font-size: 2.25em;
    line-height: 1.2;
    border-bottom: 1px solid #eee;
}
h2 {
    font-size: 1.75em;
    line-height: 1.225;
    border-bottom: 1px solid #eee;
}

/*@media print {
    .typora-export h1,
    .typora-export h2 {
        border-bottom: none;
        padding-bottom: initial;
    }

    .typora-export h1::after,
    .typora-export h2::after {
        content: "";
        display: block;
        height: 100px;
        margin-top: -96px;
        border-top: 1px solid #eee;
    }
}*/

h3 {
    font-size: 1.5em;
    line-height: 1.43;
}
h4 {
    font-size: 1.25em;
}
h5 {
    font-size: 1em;
}
h6 {
   font-size: 1em;
    color: #777;
}
p,
blockquote,
ul,
ol,
dl,
table{
    margin: 0.8em 0;
}
li>ol,
li>ul {
    margin: 0 0;
}
hr {
    height: 2px;
    padding: 0;
    margin: 16px 0;
    background-color: #e7e7e7;
    border: 0 none;
    overflow: hidden;
    box-sizing: content-box;
}

li p.first {
    display: inline-block;
}
ul,
ol {
    padding-left: 30px;
}
ul:first-child,
ol:first-child {
    margin-top: 0;
}
ul:last-child,
ol:last-child {
    margin-bottom: 0;
}
blockquote {
    border-left: 4px solid #dfe2e5;
    padding: 0 15px;
    color: #777777;
}
blockquote blockquote {
    padding-right: 0;
}
table {
    padding: 0;
    word-break: initial;
}
table tr {
    border: 1px solid #dfe2e5;
    margin: 0;
    padding: 0;
}
table tr:nth-child(2n),
thead {
    background-color: #f8f8f8;
}
table th {
    font-weight: bold;
    border: 1px solid #dfe2e5;
    border-bottom: 0;
    margin: 0;
    padding: 6px 13px;
}
table td {
    border: 1px solid #dfe2e5;
    margin: 0;
    padding: 6px 13px;
}
table th:first-child,
table td:first-child {
    margin-top: 0;
}
table th:last-child,
table td:last-child {
    margin-bottom: 0;
}

.CodeMirror-lines {
    padding-left: 4px;
}

.code-tooltip {
    box-shadow: 0 1px 1px 0 rgba(0,28,36,.3);
    border-top: 1px solid #eef2f2;
}

.md-fences,
code,
tt {
    border: 1px solid #e7eaed;
    background-color: #f8f8f8;
    border-radius: 3px;
    padding: 0;
    padding: 2px 4px 0px 4px;
    font-size: 0.9em;
}

code {
    background-color: #f3f4f4;
    padding: 0 2px 0 2px;
}

.md-fences {
    margin-bottom: 15px;
    margin-top: 15px;
    padding-top: 8px;
    padding-bottom: 6px;
}


.md-task-list-item > input {
  margin-left: -1.3em;
}

@media print {
    html {
        font-size: 13px;
    }
    table,
    pre {
        page-break-inside: avoid;
    }
    pre {
        word-wrap: break-word;
    }
}

.md-fences {
	background-color: #f8f8f8;
}
#write pre.md-meta-block {
	padding: 1rem;
    font-size: 85%;
    line-height: 1.45;
    background-color: #f7f7f7;
    border: 0;
    border-radius: 3px;
    color: #777777;
    margin-top: 0 !important;
}

.mathjax-block>.code-tooltip {
	bottom: .375rem;
}

.md-mathjax-midline {
    background: #fafafa;
}

#write>h3.md-focus:before{
	left: -1.5625rem;
	top: .375rem;
}
#write>h4.md-focus:before{
	left: -1.5625rem;
	top: .285714286rem;
}
#write>h5.md-focus:before{
	left: -1.5625rem;
	top: .285714286rem;
}
#write>h6.md-focus:before{
	left: -1.5625rem;
	top: .285714286rem;
}
.md-image>.md-meta {
    /*border: 1px solid #ddd;*/
    border-radius: 3px;
    padding: 2px 0px 0px 4px;
    font-size: 0.9em;
    color: inherit;
}

.md-tag {
    color: #a7a7a7;
    opacity: 1;
}

.md-toc { 
    margin-top:20px;
    padding-bottom:20px;
}

.sidebar-tabs {
    border-bottom: none;
}

#typora-quick-open {
    border: 1px solid #ddd;
    background-color: #f8f8f8;
}

#typora-quick-open-item {
    background-color: #FAFAFA;
    border-color: #FEFEFE #e5e5e5 #e5e5e5 #eee;
    border-style: solid;
    border-width: 1px;
}

/** focus mode */
.on-focus-mode blockquote {
    border-left-color: rgba(85, 85, 85, 0.12);
}

header, .context-menu, .megamenu-content, footer{
    font-family: "Segoe UI", "Arial", sans-serif;
}

.file-node-content:hover .file-node-icon,
.file-node-content:hover .file-node-open-state{
    visibility: visible;
}

.mac-seamless-mode #typora-sidebar {
    background-color: #fafafa;
    background-color: var(--side-bar-bg-color);
}

.md-lang {
    color: #b4654d;
}

/*.html-for-mac {
    --item-hover-bg-color: #E6F0FE;
}*/

#md-notification .btn {
    border: 0;
}

.dropdown-menu .divider {
    border-color: #e5e5e5;
    opacity: 0.4;
}

.ty-preferences .window-content {
    background-color: #fafafa;
}

.ty-preferences .nav-group-item.active {
    color: white;
    background: #999;
}

.menu-item-container a.menu-style-btn {
    background-color: #f5f8fa;
    background-image: linear-gradient( 180deg , hsla(0, 0%, 100%, 0.8), hsla(0, 0%, 100%, 0)); 
}



mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
  min-height: 1px;
  min-width: 1px;
}

mjx-container[jax="SVG"] > svg a {
  fill: blue;
  stroke: blue;
}

mjx-assistive-mml {
  position: absolute !important;
  top: 0px;
  left: 0px;
  clip: rect(1px, 1px, 1px, 1px);
  padding: 1px 0px 0px 0px !important;
  border: 0px !important;
  display: block !important;
  width: auto !important;
  overflow: hidden !important;
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  -khtml-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

mjx-assistive-mml[display="block"] {
  width: 100% !important;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][display="true"][width="full"] {
  display: flex;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line], svg[data-table] > g > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame], svg[data-table] > g > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed, svg[data-table] > g > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted, svg[data-table] > g > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > g > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

mjx-container[jax="SVG"] path[data-c], mjx-container[jax="SVG"] use[data-c] {
  stroke-width: 3;
}

g[data-mml-node="xypic"] path {
  stroke-width: inherit;
}

.MathJax g[data-mml-node="xypic"] path {
  stroke-width: inherit;
}
mjx-container[jax="SVG"] path[data-c], mjx-container[jax="SVG"] use[data-c] {
							stroke-width: 0;
						}
</style><title>Экзамен</title>
</head>
<body class='typora-export os-windows'><div class='typora-export-content'>
<div id='write'  class=''><p><img src="https://c.tenor.com/Soj9Dnl5rYkAAAAC/fat-cat-monday-morning.gif"/></p><div class='md-toc' mdtype='toc'><p class="md-toc-content" role="list"><span role="listitem" class="md-toc-item md-toc-h2" data-ref="n3"><a class="md-toc-inner" href="#1-понятие-компьютерной-сети">1. Понятие компьютерной сети</a></span><span role="listitem" class="md-toc-item md-toc-h2" data-ref="n18"><a class="md-toc-inner" href="#2-среды-передачи-данных">2. Среды передачи данных</a></span><span role="listitem" class="md-toc-item md-toc-h2" data-ref="n41"><a class="md-toc-inner" href="#3-базовые-понятия-моделей-сетевого-взаимодействия-стек-протоколов-протокол-уровень-интерфейс-сервис-точка-доступа-к-сервису">3. Базовые понятия моделей сетевого взаимодействия: стек протоколов, протокол, уровень, интерфейс, сервис, точка доступа к сервису</a></span><span role="listitem" class="md-toc-item md-toc-h2" data-ref="n82"><a class="md-toc-inner" href="#4-эталонная-модель-взаимодействия-открытых-систем-уровни-их-функции-и-принципы-выделения-уровней">4. Эталонная модель взаимодействия открытых систем: уровни, их функции и принципы выделения уровней</a></span><span role="listitem" class="md-toc-item md-toc-h3" data-ref="n84"><a class="md-toc-inner" href="#40-об-эталонной-модели-osi">4.0 Об эталонной модели OSI</a></span><span role="listitem" class="md-toc-item md-toc-h3" data-ref="n123"><a class="md-toc-inner" href="#41-физический-уровень">4.1 Физический уровень</a></span><span role="listitem" class="md-toc-item md-toc-h3" data-ref="n131"><a class="md-toc-inner" href="#42-канальный-уровень">4.2 Канальный уровень</a></span><span role="listitem" class="md-toc-item md-toc-h3" data-ref="n151"><a class="md-toc-inner" href="#43-сетевой-уровень">4.3 Сетевой уровень</a></span><span role="listitem" class="md-toc-item md-toc-h3" data-ref="n167"><a class="md-toc-inner" href="#44-транспортный-уровень">4.4 Транспортный уровень</a></span><span role="listitem" class="md-toc-item md-toc-h3" data-ref="n177"><a class="md-toc-inner" href="#45-сеансовый-уровень">4.5 Сеансовый уровень</a></span><span role="listitem" class="md-toc-item md-toc-h3" data-ref="n188"><a class="md-toc-inner" href="#46-уровень-представления-данных">4.6 Уровень представления данных</a></span><span role="listitem" class="md-toc-item md-toc-h3" data-ref="n198"><a class="md-toc-inner" href="#47-прикладной-уровень">4.7 Прикладной уровень</a></span><span role="listitem" class="md-toc-item md-toc-h2" data-ref="n209"><a class="md-toc-inner" href="#5-локальная-сеть-основные-свойства-и-их-влияние-на-выбор-технологий-передачи-данных">5. Локальная сеть: основные свойства и их влияние на выбор технологий передачи данных</a></span><span role="listitem" class="md-toc-item md-toc-h2" data-ref="n236"><a class="md-toc-inner" href="#6-сетевые-топологии-понятие-примеры-преимущества-и-недостатки-разных-топологий">6. Сетевые топологии: понятие, примеры, преимущества и недостатки разных топологий</a></span><span role="listitem" class="md-toc-item md-toc-h2" data-ref="n312"><a class="md-toc-inner" href="#7-классификации-методов-доступа-к-среде-передачи">7. Классификации методов доступа к среде передачи</a></span><span role="listitem" class="md-toc-item md-toc-h2" data-ref="n358"><a class="md-toc-inner" href="#8-метод-доступа-с-контролем-несущей-и-определением-коллизий-его-преимущества-и-недостатки">8. Метод доступа с контролем несущей и определением коллизий, его преимущества и недостатки</a></span><span role="listitem" class="md-toc-item md-toc-h2" data-ref="n394"><a class="md-toc-inner" href="#9-методы-доступа-с-передачей-маркера-их-преимущества-и-недостатки">9. Методы доступа с передачей маркера, их преимущества и недостатки</a></span><span role="listitem" class="md-toc-item md-toc-h2" data-ref="n424"><a class="md-toc-inner" href="#10-группа-стандартов-ieee-802-структура-основные-стандарты">10. Группа стандартов IEEE 802: структура, основные стандарты</a></span><span role="listitem" class="md-toc-item md-toc-h2" data-ref="n448"><a class="md-toc-inner" href="#11-протокол-управления-логическим-каналом-ieee-8022-структура-кадра-и-типы-обслуживания">11. Протокол управления логическим каналом IEEE 802.2. Структура кадра и типы обслуживания</a></span><span role="listitem" class="md-toc-item md-toc-h2" data-ref="n500"><a class="md-toc-inner" href="#12-технология-ethernet-основные-принципы-метод-доступа-его-параметры-и-ограничения-форматы-кадров">12. Технология Ethernet: основные принципы, метод доступа, его параметры и ограничения, форматы кадров</a></span><span role="listitem" class="md-toc-item md-toc-h2" data-ref="n550"><a class="md-toc-inner" href="#13-технология-token-ring-основные-принципы-метод-доступа-формат-кадра-система-приоритетного-доступа">13. Технология Token Ring: основные принципы, метод доступа, формат кадра, система приоритетного доступа</a></span><span role="listitem" class="md-toc-item md-toc-h2" data-ref="n682"><a class="md-toc-inner" href="#14-технология-fddi-основные-принципы-метод-доступа-среды-передачи">14. Технология FDDI: основные принципы, метод доступа, среды передачи</a></span><span role="listitem" class="md-toc-item md-toc-h2" data-ref="n1996"><a class="md-toc-inner" href="#15-технология-fast-ethernet-основные-принципы-отличия-от-ethernet-варианты-для-разных-сред-передачи-архитектура">15. Технология Fast Ethernet: основные принципы, отличия от Ethernet, варианты для разных сред передачи, архитектура</a></span><span role="listitem" class="md-toc-item md-toc-h2" data-ref="n752"><a class="md-toc-inner" href="#16-технология-gigabit-ethernet-основные-принципы-отличия-от-ethernet-и-fast-ethernet-варианты-для-разных-сред-передачи-интерфейс-протоколы">16. Технология Gigabit Ethernet: основные принципы, отличия от Ethernet и Fast Ethernet, варианты для разных сред передачи, интерфейс, протоколы</a></span><span role="listitem" class="md-toc-item md-toc-h2" data-ref="n775"><a class="md-toc-inner" href="#17-концентраторы-функции-варианты-конструктивного-исполнения-особенности-сетей-построенных-на-концентраторах">17. Концентраторы: функции, варианты конструктивного исполнения. Особенности сетей, построенных на концентраторах</a></span><span role="listitem" class="md-toc-item md-toc-h2" data-ref="n811"><a class="md-toc-inner" href="#18-мосты-функции-алгоритм-работы-прозрачного-моста-достоинства-и-недостатки-мостов">18. Мосты: функции, алгоритм работы прозрачного моста, достоинства и недостатки мостов</a></span><span role="listitem" class="md-toc-item md-toc-h2" data-ref="n857"><a class="md-toc-inner" href="#19-коммутаторы-функции-режимы-работы-архитектуры-ядра-коммутатора-варианты-конструктивного-исполнения">19. Коммутаторы: функции, режимы работы, архитектуры ядра коммутатора, варианты конструктивного исполнения</a></span><span role="listitem" class="md-toc-item md-toc-h2" data-ref="n988"><a class="md-toc-inner" href="#20-маршрутизаторы">20. Маршрутизаторы</a></span><span role="listitem" class="md-toc-item md-toc-h3" data-ref="n991"><a class="md-toc-inner" href="#201-функции-маршрутизатора">20.1 Функции маршрутизатора</a></span><span role="listitem" class="md-toc-item md-toc-h3" data-ref="n1007"><a class="md-toc-inner" href="#202-структура-маршрутизатора">20.2 Структура маршрутизатора</a></span><span role="listitem" class="md-toc-item md-toc-h2" data-ref="n1027"><a class="md-toc-inner" href="#21-коммутирующие-концентраторы-функции-область-применимости">21. Коммутирующие концентраторы: функции, область применимости</a></span><span role="listitem" class="md-toc-item md-toc-h2" data-ref="n1033"><a class="md-toc-inner" href="#22-алгоритм-покрывающего-дерева-на-основе-протокола-stp">22. Алгоритм покрывающего дерева на основе протокола STP</a></span><span role="listitem" class="md-toc-item md-toc-h2" data-ref="n1053"><a class="md-toc-inner" href="#23-функции-сетевого-и-транспортного-уровней-и-их-взаимосвязь">23. Функции сетевого и транспортного уровней и их взаимосвязь</a></span><span role="listitem" class="md-toc-item md-toc-h2" data-ref="n1095"><a class="md-toc-inner" href="#24-понятие-составной-сети-принципы-маршрутизации-на-основе-протоколов-rip-ospf-bgp">24. Понятие составной сети, принципы маршрутизации на основе протоколов RIP, OSPF, BGP</a></span><span role="listitem" class="md-toc-item md-toc-h2" data-ref="n1218"><a class="md-toc-inner" href="#25-алгоритмы-маршрутизации-и-их-классификация">25. Алгоритмы маршрутизации и их классификация</a></span><span role="listitem" class="md-toc-item md-toc-h2" data-ref="n1288"><a class="md-toc-inner" href="#26-структура-ip-адреса-классы-адресов-маска-сети-бесклассовая-адресация">26. Структура IP-адреса, классы адресов, маска сети. Бесклассовая адресация</a></span><span role="listitem" class="md-toc-item md-toc-h3" data-ref="n1290"><a class="md-toc-inner" href="#261-характеристика-протокола-ip">26.1 Характеристика протокола IP</a></span><span role="listitem" class="md-toc-item md-toc-h3" data-ref="n1302"><a class="md-toc-inner" href="#262-структура-адреса-на-примере-ipv4">26.2 Структура адреса на примере IPv4</a></span><span role="listitem" class="md-toc-item md-toc-h3" data-ref="n1319"><a class="md-toc-inner" href="#263-классовая-адресация">26.3 Классовая адресация</a></span><span role="listitem" class="md-toc-item md-toc-h3" data-ref="n1334"><a class="md-toc-inner" href="#264-сегментирование-сетей">26.4 Сегментирование сетей</a></span><span role="listitem" class="md-toc-item md-toc-h3" data-ref="n1370"><a class="md-toc-inner" href="#265-что-не-так-с-ipv4">26.5 Что не так с IPv4</a></span><span role="listitem" class="md-toc-item md-toc-h3" data-ref="n1379"><a class="md-toc-inner" href="#266-ipv6-да-придёт-спаситель">26.6 IPv6: да придёт спаситель</a></span><span role="listitem" class="md-toc-item md-toc-h2" data-ref="n1391"><a class="md-toc-inner" href="#27-формат-ip-пакета-их-маршрутизация-и-фрагментация">27. Формат IP-пакета, их маршрутизация и фрагментация</a></span><span role="listitem" class="md-toc-item md-toc-h3" data-ref="n1393"><a class="md-toc-inner" href="#271-инкапсуляция-и-маршрутизация-ip">27.1 Инкапсуляция и маршрутизация IP</a></span><span role="listitem" class="md-toc-item md-toc-h3" data-ref="n1400"><a class="md-toc-inner" href="#272-формат-пакета-в-ipv4">27.2 Формат пакета в IPv4</a></span><span role="listitem" class="md-toc-item md-toc-h3" data-ref="n1424"><a class="md-toc-inner" href="#273-формат-пакета-в-ipv6--не-нужно-но-может-помочь-бонусом">27.3 Формат пакета в IPv6.  <em>НЕ НУЖНО, НО МОЖЕТ ПОМОЧЬ БОНУСОМ</em></a></span><span role="listitem" class="md-toc-item md-toc-h2" data-ref="n1448"><a class="md-toc-inner" href="#28-протоколы-arp-и-rarp-функции-форматы-пакетов">28. Протоколы ARP и RARP: функции, форматы пакетов</a></span><span role="listitem" class="md-toc-item md-toc-h3" data-ref="n1450"><a class="md-toc-inner" href="#281-arp">28.1 ARP</a></span><span role="listitem" class="md-toc-item md-toc-h3" data-ref="n1481"><a class="md-toc-inner" href="#282-rarp">28.2 RARP</a></span><span role="listitem" class="md-toc-item md-toc-h2" data-ref="n1487"><a class="md-toc-inner" href="#29-протокол-icmp-функции-формат-пакета-основные-типы-пакетов-дополнительный-вопрос">29. Протокол ICMP: функции, формат пакета, основные типы пакетов. <em>ДОПОЛНИТЕЛЬНЫЙ ВОПРОС</em></a></span><span role="listitem" class="md-toc-item md-toc-h2" data-ref="n1524"><a class="md-toc-inner" href="#30-протокол-tcp-функции-формат-сегмента-и-область-применения">30. Протокол TCP: функции, формат сегмента и область применения</a></span><span role="listitem" class="md-toc-item md-toc-h3" data-ref="n1526"><a class="md-toc-inner" href="#301-характеристика-протокола-tcp">30.1 Характеристика протокола TCP</a></span><span role="listitem" class="md-toc-item md-toc-h3" data-ref="n1531"><a class="md-toc-inner" href="#302-сегментация-в-протоколе-tcp">30.2 Сегментация в протоколе TCP</a></span><span role="listitem" class="md-toc-item md-toc-h3" data-ref="n1553"><a class="md-toc-inner" href="#303-функции-протокола-tcp">30.3 Функции протокола TCP</a></span><span role="listitem" class="md-toc-item md-toc-h3" data-ref="n1566"><a class="md-toc-inner" href="#304-заголовок-протокола-tcp">30.4 Заголовок протокола TCP</a></span><span role="listitem" class="md-toc-item md-toc-h3" data-ref="n1618"><a class="md-toc-inner" href="#305-приложения-использующие-протокол-tcp">30.5 Приложения, использующие протокол TCP</a></span><span role="listitem" class="md-toc-item md-toc-h2" data-ref="n1632"><a class="md-toc-inner" href="#31-алгоритмы-управления-передачей-в-протоколе-tcp-и-их-параметры">31. Алгоритмы управления передачей в протоколе TCP и их параметры</a></span><span role="listitem" class="md-toc-item md-toc-h3" data-ref="n1634"><a class="md-toc-inner" href="#311-процессы-tcp-сервера">31.1 Процессы TCP-сервера</a></span><span role="listitem" class="md-toc-item md-toc-h3" data-ref="n1637"><a class="md-toc-inner" href="#312-установление-tcp-соединения">31.2 Установление TCP-соединения</a></span><span role="listitem" class="md-toc-item md-toc-h3" data-ref="n1647"><a class="md-toc-inner" href="#313-закрытие-tcp-соединения">31.3 Закрытие TCP-соединения</a></span><span role="listitem" class="md-toc-item md-toc-h3" data-ref="n1659"><a class="md-toc-inner" href="#314-анализ-тройного-рукопожатия">31.4 Анализ тройного рукопожатия</a></span><span role="listitem" class="md-toc-item md-toc-h2" data-ref="n1671"><a class="md-toc-inner" href="#32-протокол-udp-функции-формат-пакета-и-область-применения">32. Протокол UDP: функции, формат пакета и область применения</a></span><span role="listitem" class="md-toc-item md-toc-h3" data-ref="n1673"><a class="md-toc-inner" href="#321-характеристика-протокола-udp">32.1 Характеристика протокола UDP</a></span><span role="listitem" class="md-toc-item md-toc-h3" data-ref="n1686"><a class="md-toc-inner" href="#332-заголовок-протокола-udp">33.2 Заголовок протокола UDP</a></span><span role="listitem" class="md-toc-item md-toc-h3" data-ref="n1706"><a class="md-toc-inner" href="#334-приложения-использующие-протокол-udp">33.4 Приложения, использующие протокол UDP</a></span><span role="listitem" class="md-toc-item md-toc-h2" data-ref="n1736"><a class="md-toc-inner" href="#33-сети-hdlc">33. Сети HDLC</a></span><span role="listitem" class="md-toc-item md-toc-h2" data-ref="n1769"><a class="md-toc-inner" href="#34-принцип-работы-протокола-mpls-задачи-и-способы-организации-lsp">34. Принцип работы протокола MPLS, задачи и способы организации LSP</a></span><span role="listitem" class="md-toc-item md-toc-h2" data-ref="n1847"><a class="md-toc-inner" href="#35-dhcp">35. DHCP</a></span></p></div><h2 id='1-понятие-компьютерной-сети'><span>1. Понятие компьютерной сети</span></h2><p><img src="https://c.tenor.com/tMRY35MWfYYAAAAd/funny-silly.gif" style="zoom:50%;" /></p><p><strong><span>Компьютерная сеть</span></strong><span> – набор автономных устройств, соединённых между собой одной технологией. Такая сеть может включать как хреналион устройств (вроде интернета или китайского чебурнета), так и всего два (комп-комп, комп-телефон и так далее).</span></p><p><span>Компьютерная сеть состоит из нескольких типов компонентов:</span></p><ul><li><strong><span>Оконечные узлы (хосты).</span></strong>
<span>Это те устройства, которые могут принимать данные (являться финальным получателем) или отправлять их (являться исходным отправителем). Например, комп отправляет на удалённый телефон данные – в этой схеме, комп и телефон являются хостами (узлами).</span>
<span>У каждого оконечного устройства в сети есть адрес – он нужен, чтобы устройства можно было различать.</span></li><li><strong><span>Промежуточные устройства.</span></strong>
<span>Это те устройства, которые являются соединителями между хостами. Даже в простых сетях, которые сложнее чем &quot;уга-буга, протянуть кабель от компа к компу, стукнуть дубинка – работать&quot;, почти всегда есть хотя бы одно промежуточное устройства. Например, дома стоит роутер и несколько компов, подцепленных к нему: компы могут обмениваться данными через роутер, то есть он будет промежуточным устройством в данной сети.</span>
<span>То есть, они обеспечивают подключение и прохождение потоков данных по сети, могут подключать отдельные сети и объединять их. Для определения пути передачи сообщения, промежуточные устройства используют адрес оконечного устройства назначения в сочетании с информацией о связях в сети.</span></li><li><strong><span>Сетевые среды.</span></strong>
<span>Это любые физические штуки, через которые идёт передача данных. Так, данные можно передавать через кабели (кабель – сетевая среда). Фактически, представляет собой среду передачу данных.</span></li></ul><blockquote><p><span>Как подчёркивает Танненбаум, важно понимать разницу между компьютерной сетью и распределённой системой.</span></p></blockquote><p><span>В случае </span><strong><span>компьютерной сети</span></strong><span>, юзверь должен приложить усилия для связи с удалённым устройством – например, запустить TeamViewer через который перенести киношку на другой комп, и через который открыть её в плеере другого компа.</span></p><p><span>Во случае </span><strong><span>распределённой системы</span></strong><span>, для юзверя наличие удалённого компа неочевидно – он клацает открытие киношки, а система сама делает все необходимые действия. Интернет является лучшим примером такой системы: типичный пользователь даже не догадывается о наличии множества автономных компов – для него это всё единая связная система.</span></p><h2 id='2-среды-передачи-данных'><span>2. Среды передачи данных</span></h2><p><img src="https://c.tenor.com/gIaioChTOloAAAAC/cat-cute.gif" style="zoom:50%;" /></p><p><span>Любая коммуникация передаётся в некоторой среде. </span><strong><span>Среда передачи данных</span></strong><span> представляет собой канал, по которому сообщение передаётся от источника к адресату.</span></p><ul><li><strong><span>Металлические провода в кабелях</span></strong><span> – данные кодируются в электрические импульсы;</span></li><li><strong><span>Стеклянные или пластиковые волокна (оптоволоконный кабель)</span></strong><span> – данные кодируются в световые импульсы;</span></li><li><strong><span>Беспроводная передача</span></strong><span> – данные кодируются посредством модуляции конкретных частот электромагнитных волн.</span></li></ul><p><span>Среда передачи данных определяет:</span></p><ol start='' ><li><span>Cкорость передачи данных в сети;</span></li><li><span>Размер сети;</span></li><li><span>Требуемый набор служб (передача данных, речи, мультимедиа и т.д.), который необходимо организовать;</span></li><li><span>Требования к уровню шумов и помехозащищенности;</span></li><li><span>Общую стоимость проекта, включающая покупку оборудования, монтаж и последующую эксплуатацию.</span></li></ol><p style="text-align: center;"><img src="https://drive.google.com/uc?export=view&amp;id=15RC6sZ5S9p952fo25TZIloqlS8eEuvFP" style=" zoom: 60%;"><b></b></p><p style="text-align: center;"><b>Основные виды проводов</b></p><p></p><h2 id='3-базовые-понятия-моделей-сетевого-взаимодействия-стек-протоколов-протокол-уровень-интерфейс-сервис-точка-доступа-к-сервису'><span>3. Базовые понятия моделей сетевого взаимодействия: стек протоколов, протокол, уровень, интерфейс, сервис, точка доступа к сервису</span></h2><p><img src="https://c.tenor.com/ujI068l1JL4AAAAC/sassy-cats.gif" referrerpolicy="no-referrer"></p><p><span>Компьютерные сети работают достаточно сложно, и для представления их работы используются специальные </span><strong><span>многоуровневые модели</span></strong><span>. Их суть заключается в модулировании операций сети в управляемые уровни.</span>
<span>Проще говоря, они классифицируют операции сети по уровням.</span></p><blockquote><p><span>Уровень сетевой модели – некий класс, в который по определённым правилам заносятся сетевые операции.</span></p></blockquote><p><span>В настоящее время, основными многоуровневыми моделями являются:</span></p><ul><li><strong><span>Эталонная модель взаимодействия открытых систем</span></strong><span>, более известная как </span><strong><code>OSI</code></strong><span>.</span></li><li><strong><span>Эталонная модель TCP/IP</span></strong><span>, более известная как &quot;</span><strong><span>протокольный стек </span><code>TCP/IP</code></strong><span>&quot;.</span></li></ul><blockquote><p><span>Эталонные модели так называются, потому что их сочли достаточно годными для общего признания эталоном представления работы сети. Такую модель можно также назвать </span><strong><span>протокольным стеком</span></strong><span>, потому что фактически она представляет собой стек из протоколов.</span></p></blockquote><p style="text-align: center;"><img src="https://drive.google.com/uc?export=view&amp;id=1-Ifxk8obTSJPUwC1yPAFYHhx2R5sijjD" style=" zoom: 60%;"><b></b></p><p style="text-align: center;"><b>Эталонные модели функционирования сети</b></p><p></p><ul><li><span>Чтобы хосты могли взаимодействовать по сети, каждое устройство должно соблюдать один и тот же набор правил, называемых </span><strong><span>протоколами</span></strong><span>. Протокол обеспечивает взаимодействие компьютерных (или распределённых) сетей в пределах одного уровня модели.</span></li><li><strong><span>Интерфейс</span></strong><span> – согласование разнородных систем. В рамках эталонных моделей, интерфейс можно представить как единственного посредника для взаимодействия разных уровней.</span></li><li><strong><span>Сетевой сервис</span></strong><span>, в контексте сетевых служб, это специальный процесс ОС, обеспечивающий взаимодействие компьютеров между собой и другим сетевым оборудованием.</span></li><li><strong><span>Точка доступа к сервису (SAP)</span></strong><span> – концептуальное место, в котором один сетевой сервис одного уровня эталонной модели становится доступным ближайшему вышележащему уровню. SAP именуются в соответствии с уровнями, обеспечивающими сервис: например, транспортные услуги обеспечиваются с помощью Transport SAP (TSAP) на верхней части транспортного уровня.</span></li></ul><blockquote><p><span>Данные не могут передаваться одним цельным блоком – это неоптимально. В реальности они сегментируются (разделяются на части) и нумеруются (сегменты нужно собрать в правильном порядке).</span></p></blockquote><p><span>В рамках сетевых моделей, к сегментации добавляется ещё одно свойство: по мере перехода данных от приложения к физической среде, на каждом уровне к нему добавляется специальная информация уровня. Этот процесс называется </span><strong><span>инкапсуляцией</span></strong><span> (это как собирать матрёшку), а обратное снятие информации уровня – </span><strong><span>деинкапсуляцией</span></strong><span> (это как добираться до самой маленькой матрёшки).</span></p><blockquote><p><span>Для передачи данных по сети, исходные данные сначала оборачиваются в матрёшку  из специальной информации, а затем разворачиваются из неё.</span></p><p><span>На каждом уровне, матрёшка представляет собой массив данных, который называется </span><strong><span>единицей данных протокола (PDU)</span></strong><span>. И на каждом уровне, PDU имеет своё название:</span></p><ul><li><strong><span>Данные</span></strong><span> на уровне приложений;</span></li><li><strong><span>Сегмент</span></strong><span> на транспортном уровне;</span></li><li><strong><span>Пакет</span></strong><span> на сетевом уровне;</span></li><li><strong><span>Кадр</span></strong><span> на канальном уровне;</span></li><li><strong><span>Биты</span></strong><span> на физическом уровне.</span></li></ul></blockquote><p style="text-align: center;"><img src="https://drive.google.com/uc?export=view&amp;id=1J5cnR4DpPLT2rWhVyDJxPV1juUcqmLEw" style=" zoom: 50%;"><b></b></p><p style="text-align: center;"><b>Функционал PDU по уровням модели OSI</b></p><p></p><h2 id='4-эталонная-модель-взаимодействия-открытых-систем-уровни-их-функции-и-принципы-выделения-уровней'><span>4. Эталонная модель взаимодействия открытых систем: уровни, их функции и принципы выделения уровней</span></h2><p><img src="https://c.tenor.com/4VY0Ykn4lN4AAAAd/cat-broken-cat.gif" style="zoom:50%;" /></p><h3 id='40-об-эталонной-модели-osi'><span>4.0 Об эталонной модели OSI</span></h3><p><span>Многоуровневая модель для описания сетевых протоколов и операций обеспечивает следующие преимущества.</span></p><ul><li><strong><span>Упрощение разработки протоколов.</span></strong>
<span>Протоколы, работающие на определенном уровне, определяют формат обрабатываемых данных и интерфейс верхних и нижних уровней;</span></li><li><strong><span>Стимулирование конкуренции.</span></strong>
<span>Продукты разных поставщиков могут взаимодействовать друг с другом;</span></li><li><strong><span>Предотвращение влияния изменений технологий или функций одного уровня на другие уровни</span></strong><span> (верхние и нижние);</span></li><li><strong><span>Общий язык для описания функций сетевого взаимодействия.</span></strong></li></ul><p><span>Эталонная модель OSI определяет широкий список функций и сервисов, реализуемых на каждом уровне. Она обеспечивает единообразное применение всех сетевых протоколов и сервисов, описывая то, что необходимо сделать на определённом уровне, но не предписывая конкретные способы выполнения.</span></p><p style="text-align: center;"><img src="https://drive.google.com/uc?export=view&amp;id=1tRfDm3KoUvZylfxGGMbLSadxGNxtut-r" style=" zoom: 50%;"><b></b></p><p style="text-align: center;"><b>Уровни модели OSI</b></p><p></p><p><span>Уровни модели OSI принято называть по номеру, но их можно упоминать и по названию:</span></p><figure><table><thead><tr><th style='text-align:left;' ><span>Уровень</span></th><th style='text-align:left;' ><span>Описание</span></th></tr></thead><tbody><tr><td style='text-align:left;' ><strong><span>7. Прикладной</span></strong></td><td style='text-align:left;' ><span>Содержит протоколы для обмена данными между процессами.</span></td></tr><tr><td style='text-align:left;' ><strong><span>6. Уровень представления</span></strong></td><td style='text-align:left;' ><span>Обеспечивает общее представление данных, передаваемых между службами уровня приложений.</span></td></tr><tr><td style='text-align:left;' ><strong><span>5. Сеансовый</span></strong></td><td style='text-align:left;' ><span>Предоставляет услуги уровню представления для организации его диалога и управления обменом данными.</span></td></tr><tr><td style='text-align:left;' ><strong><span>4. Транспортный</span></strong></td><td style='text-align:left;' ><span>Определяет службы для сегментирования, передачи и повторной сборки данных для индивидуальной связи между конечными устройствами.</span></td></tr><tr><td style='text-align:left;' ><strong><span>3. Сетевой</span></strong></td><td style='text-align:left;' ><span>Предоставляет функции для обмена отдельными частями данных по сети между указанными оконечными устройствами.</span></td></tr><tr><td style='text-align:left;' ><strong><span>2. Канальный</span></strong></td><td style='text-align:left;' ><span>Описывает способы обмена кадрами данных при обмене данными между устройствами по общей среде передачи данных.</span></td></tr><tr><td style='text-align:left;' ><strong><span>1. Физический</span></strong></td><td style='text-align:left;' ><span>Представляет данные в понятном для устройств формате. Обеспечивает непосредственную взаимосвязь со средой передачи данных.</span></td></tr></tbody></table></figure><h3 id='41-физический-уровень'><span>4.1 Физический уровень</span></h3><blockquote><p><span>Отвечает за обмен физическими сигналами между физическими устройствами.</span></p></blockquote><p><span>Для передачи данных по сети необходимо сначала установить физическое подключение к ней. В качестве такого подключения может использоваться проводная или беспроводная связь по некой среде передачи данных – это зависит от сети.</span></p><p><span>Физический уровень OSI (уровень 1) обеспечивает перемещение битов, формирующих кадр канального уровня, по физической среде. Он кодирует такой кадр в виде последовательности сигналов, которые принимаются устройствами и на них восстанавливаются (тоже средствами физического уровня) в кадр.</span></p><p><span>Основные элементы уровня: физические компоненты (устройства, среды передачи и т.п), способы кодирования данных, способы передачи сигналов.</span></p><blockquote><p><span>Протоколов на этом уровне нет – работает спецназ: радиосвязь, электрические провода, волоконно-оптические провода…</span></p></blockquote><h3 id='42-канальный-уровень'><span>4.2 Канальный уровень</span></h3><blockquote><p><span>Обеспечивает установление, поддержание и разъединение соединений каналов связи.</span></p><p><span>Задача: сформировать кадры с адресом отправителя и получателя, после чего отправить их по сети.</span></p></blockquote><p><span>Канальный уровень OSI (уровень 2) подготавливает сетевые данные для физической сети. Он отвечает за связь между сетевыми интерфейсными картами, то есть его задача – работа с соединениями информационных каналов: их нужно устанавливать, поддерживать и разъединять.</span></p><blockquote><p><span>Если бы канального уровня не существовало, протоколы сетевого уровня (т.к он стоит выше), например IP, должны были бы обеспечивать соединение для всех типов средств подключения, которые могли встретиться на пути следования пакета. Более того, им пришлось бы каждый раз адаптироваться к новой сетевой технологии или среде.</span></p></blockquote><p><span>На канальном уровне, устройство имеет физический адрес – это MAC-адрес, задаваемый физическим оборудованием (сетевой платой).</span></p><p><span>По стандарту IEEE, канальный уровень делится на два отдельных подуровня:</span></p><ul><li><strong><span>Подуровень LLC (Logical Link Control)</span></strong><span>, управляющий логическими связями. Отвечает за связь с сетевым уровнем.</span></li><li><strong><span>Подуровень MAC (Media Access Control)</span></strong><span>, управляющий доступом к среде. Отвечает за инкапсуляцию данных и доступ к среде передачи данных (связь с физическим уровнем).</span></li></ul><p><span>Работа канального уровня начинается с синхронизации двух удалённых устройств.</span></p><blockquote><p><strong><span>Синхронизация</span></strong><span> – процесс установления и поддержания временных соотношений между двумя и более процессами.</span></p></blockquote><p><span>Синхронизация, в свою очередь, начинается с запуска драйвера соответствующего протокола. На компах, обычно, используется Ethernet.</span></p><blockquote><p><span>Примеры протоколов: 802.11 (беспроводная связь), Ethernet (сетевой порт компуктера), Frame Relay (как Ethernet, но специализирован на подключениях), HDLC (блть), Token Ring (блть), FDDI (блть), MPLS (блть).</span></p></blockquote><h3 id='43-сетевой-уровень'><span>4.3 Сетевой уровень</span></h3><blockquote><p><span>Выполняет маршрутизацию блоков данных через сеть.</span></p><p><span>Протоколы этого уровня занимаются построением маршрута от одного сетевого устройства к другому, с учётом всех потенциальных неполадок внутри сети.</span></p></blockquote><p><span>Сетевой уровень OSI (уровень 3) предоставляет сервисы, позволяющие хостам обмениваться данными по сети. Для этого, протоколы данного уровня выполняют четыре основных операции:</span></p><ul><li><strong><span>Адресация оконечных устройств</span></strong><span>. Хостам необходимо назначить уникальный IP-адрес для возможности их идентификации в сети;</span></li><li><strong><span>Инкапсуляция</span></strong><span>, во время которой источник IP-пакета добавляет информацию заголовка IP, например IP-адрес узла источника (отправляющего) и узла назначения (получающего).</span></li><li><strong><span>Маршрутизация</span></strong><span>. Сетевой уровень предоставляет сервисы, с помощью которых пакеты направляются к узлу назначения в другой сети. Для этого, пакет должен быть обработан маршрутизатором – он выбирает пути для пакетов и направляет их к узлу назначения (это и есть маршрутизация).</span></li><li><strong><span>Деинкапсуляция</span></strong><span>, во время которой получатель IP-пакета проверяет IP-заголовок пакета: IP-адрес назначения в нём должен совпадать с собственным IP-адресом устройства – тогда пакет, уже без заголовка IP, передаётся на транспортный уровень.</span></li></ul><blockquote><p><span>Примеры протоколов: IPv4, IPv6, ICMP (для диагностики), RIP (древняя маршрутизация по локальным сетям), BGP (маршрутизация локальных сетей в сети интернет), OSPF (маршрутизация по локальным сетям), ARP (найти MAC-адрес по IP), RARP (найти IP по MAC-адресу).</span></p></blockquote><h3 id='44-транспортный-уровень'><span>4.4 Транспортный уровень</span></h3><blockquote><p><span>Обеспечивает логическое соединение между двумя хостами.</span></p><p><span>Главная задача – транспортировка пакетов.</span></p></blockquote><p><span>Транспортный уровень OSI (уровень 4) является посредником (каналом) между уровнями приложений и сетевыми уровнями – фактически, он согласовывает их работу: транспортный уровень описывает сам механизм передачи данных, вне зависимости от их типа.</span></p><blockquote><p><span>Программы прикладного уровня генерируют данные, которыми необходимо обмениваться между узлами источника и назначения. Транспортный уровень отвечает за логические связи между приложениями, работающими на разных узлах.</span></p></blockquote><p><span>Протоколы транспортного уровня TCP и UDP используют номера портов для управления несколькими одновременными сеансами связи.</span></p><blockquote><p><span>Примеры протоколов: TCP (надёжная доставка), UDP (ненадёжная доставка).</span></p></blockquote><h3 id='45-сеансовый-уровень'><span>4.5 Сеансовый уровень</span></h3><blockquote><p><span>Управляет взаимодействием между приложениями (прикладными процессами).</span></p><p><span>Оперирует чистыми данными и отвечает за поддержку сеанса связи.</span></p></blockquote><p><span>Сеансовый уровень OSI (уровень 5) служит для установления и поддержания связи между приложениями отправителя и получателя. На данном уровне происходит обмен данными для установления связи, поддержания ее в активном состоянии и для перезапуска сеансов, которые были прерваны или неактивны в течение продолжительного времени.</span></p><blockquote><p><span>Сеансовый уровень обеспечивает взаимодействие между прикладными процессами независимо от метода и техники передачи информации (то есть, он занимается выделением ресурсов, вызовом нужных приложений и так далее).</span></p></blockquote><p><span>Именно сеансовый уровень аутентифицирует право пользователя на доступ к услуге, синхронизирует приложения, а также устанавливает соединение и поддерживает его между двумя удалёнными программами.</span></p><blockquote><p><span>Примеры протоколов: RPC (удалённый вызов процедур), NetBIOS (служба сессий на старых компах).</span></p><p><span>Видеозвонок по сети происходит через сеансовый уровень.</span></p></blockquote><h3 id='46-уровень-представления-данных'><span>4.6 Уровень представления данных</span></h3><blockquote><p><span>Определяет синтаксис передаваемой информации, то есть форму передачи информации: текста, графики, звука.</span></p><p><span>Занимается шифрованием данных, когда при передаче их необходимо защитить. </span></p></blockquote><p><span>Уровень представления OSI (уровень 6) служит для приведения данных, переданных транспортным уровнем, в вид доступный прикладному уровню. То есть, на нём форматируются данные для уровня приложений и устанавливаются стандарты форматов файлов.</span></p><blockquote><p><span>Фактически, данный уровень представляет сообщение в той форме, которая необходима получателю.</span></p></blockquote><p><span>Следовательно, функции уровня сводятся к обеспечению шифровки/дешифровки данных, а также к их сжатию/распаковке.</span></p><blockquote><p><span>Примеры протоколов: ASCII (соответствие кодировок), SSL (криптография), TLS (криптография покруче).</span></p></blockquote><h3 id='47-прикладной-уровень'><span>4.7 Прикладной уровень</span></h3><blockquote><p><span>Своеобразный GUI между моделью OSI и пользователем.</span></p></blockquote><p><span>Прикладной уровень OSI (уровень 7) обеспечивает работу и взаимодействие сетевых приложений с базовой сетью, по которой передаются сообщения. Данный уровень определяет семантику информации, то есть её смысловое содержание.</span></p><blockquote><p><span>Протоколы уровня приложений используются для обмена данными между программами, выполняемыми на узле источника и узле назначения.</span></p></blockquote><p><span>Основные функции уровня сводятся к обеспечению интерфейса между пользователем и общесетевыми службами, а также аутентификация пользователя по имени и паролю.</span></p><p><span>На прикладном уровне работают браузеры, всякие приложения типа Steam и BattleNet.</span></p><blockquote><p><span>Примеры протоколов: HTTP (передача данных через запросы), FTP (передача файлов по сети), Telnet (связь через терминал), SSH (безопасное удалённое подключение), SMTP (передача почты), DHCP (динамическая настройка IP на узле).</span></p></blockquote><p><img src="https://c.tenor.com/OVUDwIM8mBkAAAAd/cat-cat-stare.gif" style="zoom:50%;" /></p><h2 id='5-локальная-сеть-основные-свойства-и-их-влияние-на-выбор-технологий-передачи-данных'><span>5. Локальная сеть: основные свойства и их влияние на выбор технологий передачи данных</span></h2><p><img src="https://c.tenor.com/fh6juClXJGgAAAAd/%D9%82%D8%B7%D8%A9-%D8%A7%D9%84%D8%B9%D9%85%D8%A7%D8%B1%D9%8A.gif" style="zoom:50%;" /></p><p><span>Большинство компьютерных сетей используется небольшими предприятиями или частными лицами (простыми людьми, живущими своей жизнью), и соответственно сами сети также невелики. Небольшие сети, обычно, довольно просты: в них, количество устройств и их типов существенно меньше по сравнению с большими сетями.</span></p><p><strong><span>Локально-вычислительными сетями</span></strong><span> (</span><code>ЛВС</code><span> или </span><code>LAN</code><span>) называют частные сети, размещающиеся, как правило, в одном здании или на территории какой-либо организации. Их часто используют для объединения хостов для предоставления совместного доступа к ресурсам (например, принтерам) и обмена информацией.</span></p><blockquote><p><span>ЛВС охватывают абонентов на небольшом (до 10-15км) расстоянии друг от друга. Количество рабочих станций зависит от ОС и технологий, которые используются для формирования такой сети.</span></p><p><span>Пример технологий ЛВС: arpanet, arcnet, TokenRing, Ethernet;</span></p></blockquote><p><span>Сейчас очень популярны беспроводные ЛВС, применяемые в помещениях где неудобно или сложно провести кабели. В таких системах у каждого устройства есть радиомодем и антенна, которую он использует для взаимодействия с другими хостами.</span></p><blockquote><p><span>В беспроводных сетях часто используется точка доступа – беспроводной маршрутизатор (или базовая станция) который передаёт пакеты между устройствами в сети и интернетом.</span></p></blockquote><p><strong><span>Особенности LAN:</span></strong></p><ul><li><span>Сети LAN связывают оконечные устройства в ограниченной области, например в доме, школе, офисном здании или комплексе зданий;</span></li><li><span>Сети LAN обычно администрирует одна организация или частное лицо. Административный контроль осуществляется на уровне сети и управляет политиками безопасности и контроля доступа;</span></li><li><span>Сети LAN предоставляют высокоскоростной доступ к внутренним оконечным и промежуточным устройствам.</span></li></ul><p><strong><span>Глобальная сеть (WAN)</span></strong><span> – сетевая инфраструктура, охватывающая обширную территорию. Обычно принадлежит и находится под управлением больших корпораций или провайдеров телекоммуникационных услуг.</span></p><p><strong><span>Особенности WAN:</span></strong></p><ul><li><span>Сети WAN связывают локальные сети в обширных географических областях, таких как города, штаты, регионы, страны или континенты;</span></li><li><span>Управляют глобальными сетями обычно различные операторы связи SP или Интернет-провайдеры ISP;</span></li><li><span>Сети WAN обычно обеспечивают менее скоростные соединения между локальными сетями.</span></li></ul><h2 id='6-сетевые-топологии-понятие-примеры-преимущества-и-недостатки-разных-топологий'><span>6. Сетевые топологии: понятие, примеры, преимущества и недостатки разных топологий</span></h2><p><img src="https://c.tenor.com/Bid8b-ni4EMAAAAd/cat-cat-standing.gif" style="zoom:50%;" /></p><p><strong><span>Физическая топология</span></strong><span> – одна из главных характеристик сети. Формируется физически, из устройств и сред передачи данных. Является конфигурацией графа, в котором вершины отображают конечные узлы сети, а рёбра – физические или информационные связи между устройствами.</span></p><blockquote><p><span>Сетевая поптология определяет связность сети: чем больше связей на узел, тем лучше её связность (ваш капитан Очевидность).</span></p></blockquote><p><span>В настоящее время, есть четыре основных топологии: шина, кольцо, звезда, расширенная звезда. Топологии &quot;</span><em><span>шина</span></em><span>&quot; и &quot;</span><em><span>кольцо</span></em><span>&quot; считаются устаревшими, но использовались на этапах раннего развития технологий Ethernet.</span></p><p style="text-align: center;"><img src="https://drive.google.com/uc?export=view&amp;id=1ixjbH6P77Z2vARucjCN3keI6HHOqBFp7" style=" zoom: 70%;"><b></b></p><p style="text-align: center;"><b>Физические топологии сети</b></p><p></p><ol start='' ><li><p><span>Топология </span><strong><code>шина</code></strong><span> </span><span style="color:RED"><strong><span>УСТАРЕВШАЯ ТЕХНОЛОГИЯ, -20 К МОДИФИКАТОРУ ПРОГРЕССА</span></strong></span></p><ul><li><strong><span>Работает на основе конкуретного метода CSMA/CD (множественный метод доступа с контролем несущей и обнаружением коллизий);</span></strong></li><li><span>Все хосты связаны друг с другом общим коаксиальным кабелем, имеющим на концах специальные заглушки &quot;терминаторы&quot;;</span></li><li><span>Для соединения хостов не требуются коммутаторы;</span></li><li><span>Использовалась на заре Ethernet, благодаря своей дешевизне и простоте монтажа.</span></li><li class='md-task-list-item task-list-item task-list-done' ><input type='checkbox' checked/><p><span>Легко реконфигурируется и масштабируется;</span></p></li><li class='md-task-list-item task-list-item task-list-done' ><input type='checkbox' checked/><p><span>Работает даже при выходе из строй рабочей станции.</span></p></li><li class='md-task-list-item task-list-item task-list-not-done' ><input type='checkbox' /><p><span>Длина сегмента всего 1.8 метра, на который приходится не более 30 узлов;</span></p></li><li class='md-task-list-item task-list-item task-list-not-done' ><input type='checkbox' /><p><span>На разных участках сети нельзя применять разные типы кабелей;</span></p></li><li class='md-task-list-item task-list-item task-list-not-done' ><input type='checkbox' /><p><span>Неисправность в кабеле неотдебажить без везения уровня D20.</span></p></li></ul></li><li><p><span>Топология </span><strong><code>кольцо</code></strong><span> </span><span style="color:RED"><strong><span>УСТАРЕВШАЯ ТЕХНОЛОГИЯ, -20 К МОДИФИКАТОРУ ПРОГРЕССА</span></strong></span></p><ul><li><strong><span>Работает на основе маркерного метода передачи права;</span></strong></li><li><span>Каждый хост соединяется с соседним, образуя сеть в форме кольца;</span></li><li><span>Топология использовалась в устаревших сетях FDDI и Token Ring;</span></li><li><span>Простейшая топология, поддерживающая защиту от отказов;</span></li><li><span>Передача идёт по кольцу, но только в одном направлении – по часовой стрелке.</span></li><li class='md-task-list-item task-list-item task-list-done' ><input type='checkbox' checked/><p><span>Каждый узел усиливает сигнал (является регенератором), но суммарно лишь до 500 метров;</span></p></li><li class='md-task-list-item task-list-item task-list-done' ><input type='checkbox' checked/><p><span>На разных участках можно использовать разный тип кабеля.</span></p></li><li class='md-task-list-item task-list-item task-list-not-done' ><input type='checkbox' /><p><span>Низкая надёжность – вылет даже одной рабочей станции роняет сеть;</span></p></li><li class='md-task-list-item task-list-item task-list-not-done' ><input type='checkbox' /><p><span>Низкая скорость – обновление информации происходит путём перемещения по сети маркера, который запрашивает у станции информацию о наличии новых данных.</span></p></li></ul></li><li><p><span>Топология </span><strong><code>звезда</code></strong></p><ul><li><strong><span>Работает на основе метода опроса: центральный узел опрашивает каждый хост на наличие информации для передачи;</span></strong></li><li><span>Формируется на базе центрального узла – от него идут связи ко всем другим узлам сети;</span></li><li><span>Весь сетевой трафик проходит через центральный узел;</span></li><li><span>Одновременно лишь один хост может пересылать данные (если в центре концентратор, для коммутатора это неактуально).</span></li><li class='md-task-list-item task-list-item task-list-done' ><input type='checkbox' checked/><p><span>Вылет хоста (если это не центральный узел) не влияет на работу сети;</span></p></li><li class='md-task-list-item task-list-item task-list-done' ><input type='checkbox' checked/><p><span>Лёгкий поиск и фикс неисправностей;</span></p></li><li class='md-task-list-item task-list-item task-list-done' ><input type='checkbox' checked/><p><span>Низкая стоимость сети.</span></p></li><li class='md-task-list-item task-list-item task-list-not-done' ><input type='checkbox' /><p><span>Если выпал центральный узел, на Набу отключаются все дроиды;</span></p></li><li class='md-task-list-item task-list-item task-list-not-done' ><input type='checkbox' /><p><span>На центральный узел идёт огромная нагрузка;</span></p></li><li class='md-task-list-item task-list-item task-list-not-done' ><input type='checkbox' /><p><span>Масштабируемость ограничена количеством портов на центральном узле.</span></p></li></ul></li><li><p><span>Топология </span><strong><code>расширенная звезда</code></strong></p><ul><li><span>Продвинутая форма звезды – к центральному узлу могут быть присоединены другие центральные узлы, что масштабирует сеть;</span></li><li><span>Используется в современных крупных локальных сетях (зачастую, в гибридном виде – когда топологии комбинируются).</span></li></ul></li></ol><h2 id='7-классификации-методов-доступа-к-среде-передачи'><span>7. Классификации методов доступа к среде передачи</span></h2><p><img src="https://c.tenor.com/PhhN-3LjE3AAAAAd/gatto-cibo.gif" style="zoom:50%;" /></p><blockquote><p><span>Согласно CISCO, современные сети Ethernet работают в полнодуплексном режиме и не требуют наличия метода управления доступом. Следовательно, вся перечисленная ниже информация может быть распечатана на туалетной бумаге формата А5.</span></p></blockquote><p><span>Любое оборудование функционирует в соответствии с законами физики. Так, сетевое оборудование обладает двумя группами способов получения доступа к среде передачи данных:</span></p><ol start='' ><li><p><strong><span>Детерминированные (контролируемые) методы доступа.</span></strong>
<span>Специальный алгоритм делит время использования среды передачи хостами. То есть, узлы получают доступ к среде в предопределённом порядке, а сама эта последовательность определяется центральным узлом – контролл*ром сети.</span></p><ul><li class='md-task-list-item task-list-item task-list-done' ><input type='checkbox' checked/><p><span>Позволяет использовать канал связи с высокой эффективностью;</span></p></li><li class='md-task-list-item task-list-item task-list-done' ><input type='checkbox' checked/><p><span>Есть возможность приоритетной передачи.</span></p></li><li class='md-task-list-item task-list-item task-list-not-done' ><input type='checkbox' /><p><span>Сеть неэффективна, так как устройство должно дожидаться своей очереди для доступа к сети;</span></p></li><li class='md-task-list-item task-list-item task-list-not-done' ><input type='checkbox' /><p><span>Обязателен центральный узел для управления;</span></p></li><li class='md-task-list-item task-list-item task-list-not-done' ><input type='checkbox' /><p><span>Должен быть разработан алгоритм управления маркером.</span></p></li></ul><blockquote><p><span>Популярные детерминированные методы доступа:</span></p><ul><li><span>Метод опроса;</span></li><li><span>Метод передачи права;</span></li><li><span>Метод кольцевых слотов.</span></li></ul></blockquote></li><li><p><strong><span>Недетерминированные (конкурентные) методы доступа.</span></strong>
<span>Хосты &quot;состязаются&quot; за доступ к среде передачи данных. Так, одновременная передача данных с нескольких станций приводит к появлению коллизий.</span></p><ul><li class='md-task-list-item task-list-item task-list-done' ><input type='checkbox' checked/><p><span>Прост в реализации, так как весь &quot;алгоритм&quot; по умолчанию встроен в сетевой адаптер;</span></p></li><li class='md-task-list-item task-list-item task-list-done' ><input type='checkbox' checked/><p><span>Не требует центрального узла для управления.</span></p></li><li class='md-task-list-item task-list-item task-list-not-done' ><input type='checkbox' /><p><span>Одновременно данные может отправлять лишь одно устройство;</span></p></li><li class='md-task-list-item task-list-item task-list-not-done' ><input type='checkbox' /><p><span>Сеть фактически работает лишь в полудуплексном режиме (когда один говорит, а перебивать нельзя);</span></p></li><li class='md-task-list-item task-list-item task-list-not-done' ><input type='checkbox' /><p><span>Возникают отказы передачи сообщений;</span></p></li><li class='md-task-list-item task-list-item task-list-not-done' ><input type='checkbox' /><p><span>Возможны большие задержки при передаче.</span></p></li></ul><blockquote><p><span>Популярные недетерминированные методы доступа:</span></p><ul><li><span>CSMA/CD – множественный метод доступа с контролем несущей и обнаружением коллизий;</span></li></ul></blockquote></li></ol><h2 id='8-метод-доступа-с-контролем-несущей-и-определением-коллизий-его-преимущества-и-недостатки'><span>8. Метод доступа с контролем несущей и определением коллизий, его преимущества и недостатки</span></h2><p><img src="https://c.tenor.com/2T506UHvonMAAAAC/pirate-cat.gif" style="zoom:67%;" /></p><p><span>Примитивные сети, из тех что функционируют на базе Ethernet, имеют общую среду передачи данных. А раз среда общая, то в ней возможны коллизии. Среди примеров таких сетей, особо выделяются:</span></p><ul><li><span>Устаревшая топология </span><code>шина Ethernet LAN</code><span>;</span></li><li><span>Устаревшие сети Ethernet на базе концентратора.</span></li></ul><blockquote><p><span>Большинство современных сетей, функционирующих на базе Ethernet, больше не обладают общей средой передачи данных – она была вытеснена коммутируемыми соединениями.</span></p></blockquote><p><span>Если два устройства выполняют передачу одновременно, то возникает конфликт – </span><strong><span>коллизия</span></strong><span>. Данные, передаваемые обоими устройствами, будут повреждены, из-за чего потребуется их повторная отправка.</span></p><p><span>Решить проблему можно с помощью </span><strong><span>CSMA/CD</span></strong><span> – метода множественного доступа (</span><code>Multitple Access</code><span> или </span><code>MA</code><span>) с контролем несущей (</span><code>Carrier Sence</code><span> или </span><code>CS</code><span>) и обнаружением коллизий (</span><code>Collision Detect</code><span> или </span><code>CD</code><span>).</span></p><blockquote><p><span>CSMA/CD – полудуплексная архитектура, то есть одновременно возможна передача лишь от одной станции.</span></p></blockquote><p><span>Начинать передачу имеет право любой компьютер сети (</span><code>Multiple Access</code><span>), но перед началом передачи компьютер должен проверить, свободна ли линия (измерить напряжение). Это достигается прослушиванием основной гармоники сигнала, которая также называется несущей частотой (</span><code>Carrier Sense</code><span>). Признак незанятости – отсутствие несущей частоты.</span></p><p><span>Компьютер начавший передачу контролирует её до конца передачи. В случае изменения сигнала обнаруживается коллизия (</span><code>Collision Detect</code><span>), после этого передача прекращается и запускается аварийный сигнал, и устройства повторяют передачу спустя некоторое случайное время (предварительно &quot;прослушав&quot; канал на предмет занятости).</span></p><p><span>Для получения информации устройство должно принимать все пакеты в сети, чтобы определить, не оно ли является адресатом.</span></p><ul><li class='md-task-list-item task-list-item task-list-done' ><input type='checkbox' checked/><p><span>Лёгкость включения новых станций;</span></p></li><li class='md-task-list-item task-list-item task-list-done' ><input type='checkbox' checked/><p><span>Отсутствие управляющих кадров;</span></p></li><li class='md-task-list-item task-list-item task-list-done' ><input type='checkbox' checked/><p><span>Разрешение конфликтов;</span></p></li><li class='md-task-list-item task-list-item task-list-done' ><input type='checkbox' checked/><p><span>Система позволяет изменить требования к передаче данных;</span></p></li><li class='md-task-list-item task-list-item task-list-done' ><input type='checkbox' checked/><p><span>Не нужен централизованный контроллер шины.</span></p></li><li class='md-task-list-item task-list-item task-list-not-done' ><input type='checkbox' /><p><span>Сбой в передаче данных на устройство будет обнаружен лишь при запросе от этого устройства;</span></p></li><li class='md-task-list-item task-list-item task-list-not-done' ><input type='checkbox' /><p><span>Усложнение конфигурации сети;</span></p></li><li class='md-task-list-item task-list-item task-list-not-done' ><input type='checkbox' /><p><span>Не достигается чётко определённое время отклика;</span></p></li><li class='md-task-list-item task-list-item task-list-not-done' ><input type='checkbox' /><p><span>Система постоянно должна обнаруживать конфликты, избегать их и реализовывать планы восстановления.</span></p></li></ul><h2 id='9-методы-доступа-с-передачей-маркера-их-преимущества-и-недостатки'><span>9. Методы доступа с передачей маркера, их преимущества и недостатки</span></h2><p><img src="https://c.tenor.com/nXNHCwBK_M4AAAAC/lazy-cat.gif" referrerpolicy="no-referrer"></p><p><span>Суть методов доступа с передачей маркера основывается на применении пакета особого типа – </span><strong><span>маркера (token)</span></strong><span>, который циркулирует по кольцу от компьютера к компьютеру. Чтобы послать данные в сеть, любой из компьютеров сначала должен дождаться прихода свободного маркера и захватить его. Когда какой-либо компьютер «наполнит» маркер своей информацией и отправит его по сетевому кабелю, другие компьютеры уже не могут передавать данные.</span></p><blockquote><p><span>Поскольку в каждый момент времени только один компьютер будет использовать маркер, в сети не возникнет ни состязания, ни коллизий, ни временных пауз.</span></p></blockquote><ul><li class='md-task-list-item task-list-item task-list-done' ><input type='checkbox' checked/><p><span>Является детерминированным (контролируемым), поэтому его можно применять в системах управления некоторыми видами автоматического оборудования;</span></p></li><li class='md-task-list-item task-list-item task-list-done' ><input type='checkbox' checked/><p><span>Системы с данным методом обладают большой гибкостью, так как правила доступа к каналу напрямую влияют на эффективность использования пропускной полосы канала;</span></p></li><li class='md-task-list-item task-list-item task-list-done' ><input type='checkbox' checked/><p><span>Эффективность использования пропускной полосы канала растёт вместе с трафиком данных, а по достижению некоторого уровня, не убывает, но и не возрастает (то есть, трафик растёт – а сети от этого больно не делается);</span></p></li><li class='md-task-list-item task-list-item task-list-not-done' ><input type='checkbox' /><p><span>Нужно реализовывать довольно сложное ПО, локализованное во всех подключенных к сети устройствах;</span></p></li><li class='md-task-list-item task-list-item task-list-not-done' ><input type='checkbox' /><p><span>Сам метод более громоздкий и медленный;</span></p></li><li class='md-task-list-item task-list-item task-list-not-done' ><input type='checkbox' /><p><span>Плохо приспособлен к неравномерной загрузке сети;</span></p></li><li class='md-task-list-item task-list-item task-list-not-done' ><input type='checkbox' /><p><span>Внутренний мониторинг состояния сети, включающий процедуры обнаружения ошибок и восстановления, требует участия всех активных устройств сети;</span></p></li><li class='md-task-list-item task-list-item task-list-not-done' ><input type='checkbox' /><p><span>Некоторые сети требуют наличие дополнительного центрального контроллера, а работоспособность сети влияет на эффективную полосу пропускания.</span></p></li></ul><p><span>К методам доступа с передачей маркера относятся:</span></p><ol start='' ><li><strong><span>Метод опроса.</span></strong>
<span>Центральный узел опрашивает каждую станцию на наличие информации для передачи.</span>
<span>Если у станции есть информация для передачи, то центральный узел предоставляет ей монопольное право для передачи сообщения, выделяя полосу для пропускания.</span></li><li><strong><span>Метод передачи права.</span></strong>
<span>Базируется на кольцевой топологии. По сети перемещается маркер и опрашивает каждый узел на наличие передаваемой информации.</span>
<span>Если у станции есть информации, к маркеру прибавляется кадр, после чего этот паровозик перемещается по сети.</span>
<span>Каждый промежуточный узел просматривает адресный узел и пропускает паровозик дальше, если сообщение не предназначено ему.</span>
<span>Станция-получатель выгружает данные и устанавливает в статусе пакета &quot;адрес распознаны, данные скопированы&quot;, а затем отправляет &quot;маркер + кадр&quot; по оставшемуся пути кольца, вплоть до станции отправившей кадр.</span>
<span>Узел-отправитель определяет, что сообщение доставлено и освобождает кадр.</span>
<span>Если кадр оказался не отправлен – он отправляется повторно.</span></li><li><strong><span>Метод кольцевых слотов (логических элементов).</span></strong>
<span>Работает при наличии двухкольцевой топологии FDDI. Базируется на оптоволокне.</span>
<span>Принцип как у метода передачи права, но по кольцу перемещается 2-8 маркеров.</span>
<span>Недостатков у топологии нет. Если какой-то узел отключается – происходит автосегментация и он выкидывается из сети.</span></li></ol><h2 id='10-группа-стандартов-ieee-802-структура-основные-стандарты'><span>10. Группа стандартов IEEE 802: структура, основные стандарты</span></h2><p><img src="https://c.tenor.com/NDJLxTnxbsMAAAAd/cat-bed-laying-lazy-dzekas.gif" style="zoom:50%;" /></p><p><span>Существует семейство стандартов для стандартизации физической составляющей сетей, и методов прямого взаимодействия с ними – это группа стандартов IEEE 802. Соответственно, модели OSI они охватывают физический и канальный уровень, а в модели TCP/IP – уровень сетевых интерфейсов.</span></p><p><span>Стандарты IEEE 802 многочисленны, но на профессиональные сети начального уровня влияют следующие три стандарта: </span></p><ul><li><span>Ethernet (802.3);</span></li><li><span>Беспроводные локальные сети (802.11);</span></li><li><span>Беспроводные сети (802.15).</span></li></ul><p style="text-align: center;"><img src="https://drive.google.com/uc?export=view&amp;id=1mlKjWgPqTJhiRBq21YWUFU5C1VLtmASf" style=" zoom: 30%;"><b></b></p><p style="text-align: center;"><b>Структура стандартов IEEE 802</b></p><p></p><p><span>Стандартами IEEE 802 также определено разделение канального уровня OSI на два подуровня:</span></p><ul><li><p><strong><span>Подуровень логической передачи данных </span><code>Logical Link Control</code><span> или </span><code>LLC</code><span>.</span></strong>
<span>Уровень LLC отвечает за передачу кадров данных между узлами с различной степенью надёжности, а также реализует функции интерфейса с прилегающим к нему сетевым уровнем.</span></p><blockquote><p><span>Именно через данный подуровень сетевой протокол запрашивает у канального уровня нужную ему транспортную операцию с нужным качеством.</span></p></blockquote></li><li><p><strong><span>Подуровень управления доступом к среде </span><code>Media Access Control</code><span> или </span><code>MAC</code><span>.</span></strong>
<span>Уровень MAC появился из-за существования в локальных сетях разделяемой среды передачи данных. Именно данный подуровень обеспечивает корректное совместное использование общей среды, предоставляя её в распоряжение нужного хоста сети. После того как доступ к среде получен, ею может пользоваться более высокий уровень – уровень LLC.</span></p></li></ul><blockquote><p><span>Протоколы уровней MAC и LLC взаимно независимы – каждый протокол уровня MAC может применяться с любым протоколом уровня LLC, и наоборот.</span></p></blockquote><p><span>Особняком стоят стандарты, разрабатываемые подкомитетом 802.1 – они носят общий для всех технологий характер: это общие определения локальных сетей и их свойств, определение связи трёх уровней модели IEEE 802 с моделью OSI, стандарты межсетевого взаимодействия </span><code>internetworking</code><span>.</span></p><p><span>Стандарты 802.3 (Ethernet Digital Intel и Xerox), 802.4 (обобщение ArcNet), 802.5 (Token Ring) и 802.12 описывают технологии локальных сетей, которые появились в результате улучшений фирменных технологий, лежащих в их основе.</span></p><h2 id='11-протокол-управления-логическим-каналом-ieee-8022-структура-кадра-и-типы-обслуживания'><span>11. Протокол управления логическим каналом IEEE 802.2. Структура кадра и типы обслуживания</span></h2><p><img src="https://c.tenor.com/QAN9RxLUSxUAAAAC/cat-cute.gif" style="zoom:80%;" /></p><p><span>Стандарт 802.2 описывает протоколы управления логическим каналом LLC. Так, в основу протокола LLC положен протокол HDLC.</span></p><p><span>В соответствии со стандартом 802.2 уровень управления логическим каналом LLC предоставляет верхним уровням три типа процедур:</span></p><ul><li><p><strong><code>LLC1</code><span> – сервис без установления соединения и без подтверждения.</span></strong>
<span>Даёт пользователю средства для передачи данных с минимумом издержек. Обычно используется тогда, когда протоколы вышестоящих уровней выполняют функции типа восстановления данных после ошибок и упорядочивания данных.</span></p><blockquote><p><span>Выполняется когда не нужно дублировать функции упорядочивания данных и восстановления данных после ошибок.</span></p><p><span>Из типов обслуживания, чаще всего в локальных сетях используется именно LLC1.</span></p></blockquote></li><li><p><strong><code>LLC2</code><span> – сервис с установлением соединения и подтверждением.</span></strong>
<span>Даёт пользователю возможность установить логическое соединение перед началом передачи любого блока данных и, если это требуется, выполнить процедуры восстановления после ошибок и упорядочивание потока этих блоков в рамках установленного соединения.</span></p><blockquote><p><span>Выполняется когда нужно обеспечить надёжную передачу кадров на зашумлённых линиях.</span></p></blockquote></li><li><p><strong><code>LLC3</code><span> – сервис без установления соединения, но с подтверждением.</span></strong>
<span>Дополнительный сервис, применяемый когда неприемлимы временные издержки установления логического соединения перед отправой данных, но подтверждать корректность приёма данных необходимо.</span></p><blockquote><p><span>Выполняется сетями в системах реального времени (управляют промышленными и военными объектами) и им подобным.</span></p></blockquote></li></ul><p><strong><span>Кадры уровня LLC, в стандарте 802.2, называются блоками данных PDU и подразделяются на три типа:</span></strong></p><ul><li><strong><span>Информационные кадры.</span></strong>
<span>Предназначены для передачи информации в процедурах с установлением логического соединения и должны обязательно содержать поле информации. В процессе передачи информационных блоков осуществляется их нумерация в режиме скользящего окна.</span></li><li><strong><span>Управляющие кадры.</span></strong>
<span>Предназначены для передачи команд и ответов в процедурах с установлением логического соединения, в том числе запросов на повторную передачу искаженных информационных блоков.</span></li><li><strong><span>Ненумерованные кадры.</span></strong>
<span>Предназначены для передачи ненумерованных команд и ответов, выполняющих в процедурах без установления логического соединения передачу информации, идентификацию и тестирование LLC-уровня, а в процедурах с установлением логического соединения – установление и разъединение логического соединения, а также информирование об ошибках.</span></li></ul><p><strong><span>Все типы кадров LLC имет один общий формат и содержат четыре поля:</span></strong></p><ol start='' ><li><strong><span>Адрес точки входа сервиса назначения (Destination Service Access Point, </span><code>DSAP</code><span>).</span></strong>
<span>Позволяет указать, какой сервис верхнего уровня получает данные с помощью кадра.</span></li><li><strong><span>Адрес точки входа сервиса источника (Source Service Access Point, </span><code>SSAP</code><span>).</span></strong>
<span>Позволяет указать, какой сервис верхнего уровня пересылает данные с помощью кадра.</span></li><li><strong><span>Управляющее поле (Control, </span><code>CTRL</code><span>).</span></strong>
<span>Используется для обозначения типа данных кадра.</span>
<span>Если подуровень работает по процедуре LLC2, то в нём также указываются порядковые номера отправленныз и успешно принятых кадров.</span></li><li><strong><span>Поле данных (</span><code>Data</code><span>).</span></strong>
<span>Предназначено для передачи по сети пакетов протоколов верхних уровней.</span>
<span>Может отсутствовать в управляющих кадрах и некоторых ненумерованных кадрах.</span></li></ol><p><span>Кадр LLC обрамляется двумя однобайтовыми полями &quot;Флаг&quot;, имеющими значение 01111110. Флаги используются на MAC-уровне для определения границ блока.</span></p><figure><table><thead><tr><th style='text-align:center;' ><span>Флаг</span></th><th style='text-align:center;' ><span>DSAP</span></th><th style='text-align:center;' ><span>SSAP</span></th><th style='text-align:center;' ><span>CTRL</span></th><th style='text-align:center;' ><span>DATA</span></th><th style='text-align:center;' ><span>Флаг</span></th></tr></thead><tbody><tr><td style='text-align:center;' ><span>01111110</span></td><td style='text-align:center;' ><span>Адрес точки входа сервиса назначения</span></td><td style='text-align:center;' ><span>Адрес точки входа сервиса источника</span></td><td style='text-align:center;' ><span>Управляющее поле</span></td><td style='text-align:center;' ><span>Данные</span></td><td style='text-align:center;' ><span>01111110</span></td></tr></tbody></table></figure><h2 id='12-технология-ethernet-основные-принципы-метод-доступа-его-параметры-и-ограничения-форматы-кадров'><span>12. Технология Ethernet: основные принципы, метод доступа, его параметры и ограничения, форматы кадров</span></h2><p><img src="https://c.tenor.com/oTeBa4EVepMAAAAC/business-cat-working.gif" referrerpolicy="no-referrer"></p><p><strong><span>Ethernet</span></strong><span> – семейство технологий пакетной передачи данных между устройствами для компьютерных и промышленных сетей. Является самым распространённым стандартом локальных сетей.</span></p><p><span>Основа стандарта – IEEE 802.3, однако существует ряд модификаций, подстроенных под соответствующий тип физической среды. Эти модификации описываются уже другими стандартами.</span></p><p><span>К общим характеристикам архитектуры сетей классического Ethernet IEEE 802.3 можно отнести:</span></p><ul><li><p><span>Строится по принципу &quot;точка-точка&quot;: к одному кабелю Ethernet присоединяется ровно два устройства;</span></p><blockquote><p><span>Двое их, не больше, и не меньше: учитель и его ученик.</span></p></blockquote></li><li><p><span>Доступ к среде передачи – CSMA/CD, то есть &quot;множественный доступ с контролем несущей и обнаружением коллизий&quot;;</span></p></li><li><p><span>Информационный блок является кадром;</span></p></li><li><p><span>Размер кадра не превышает 1518 байт (без учёта преамбулы на 8 байт и завершителя кадра на 1 байт);</span></p></li><li><p><span>Обмен кадрами – широковещательный, с проверкой адресаата;</span></p></li><li><p><span>Среда передачи – коаксиальный кабель, витая пара, оптоволоконный кабель;</span></p></li><li><p><span>Поддерживаемая скорость передачи данных – 10, 100 и 1000 Мбит/с;</span></p></li><li><p><span>Физическая топология (физическое соединение устройств) – шина или звезда;</span></p></li><li><p><span>Логическая топология (виртуальное соединение устройств) – только шина;</span></p></li><li><p><span>Размер сети – от нескольких метров до нескольких километров (если в сети используются повторители).</span></p></li></ul><p><strong><span>Кадр Ethernet состоит из трёх основных частей:</span></strong></p><ol start='' ><li><p><strong><span>Заголовок.</span></strong>
<span>Заголовок кадра Ethernet играет роль информатора – в нём содержится основная информация для системы: MAC-адреса исходной и конечной точки доставки, а также тип протокола вышестоящего уровня, матрёшка которого передаётся в данных.</span></p><blockquote><p><span>ПРИМЕР (запоминать не нужно, он чисто для понимания):</span></p><p><span>В поле типа протокола может храниться значение </span><code>0x0800</code><span>, которое означает, что в данных передаётся пакет, сформированный протоколом IPv4.</span></p></blockquote></li><li><p><strong><span>Данные.</span></strong>
<span>Данные, получаемые от протоколов вышестоящего уровня. То есть, это поле хранит матрёшку заголовков сетевого, транспортного и т.п уровней, внутри которых уже и хранится пользовательская информация.</span></p><blockquote><p><span>Чаще всего, в поле &quot;данные&quot; будет храниться кадр формата IP.</span></p></blockquote></li><li><p><strong><span>Концевик.</span></strong>
<span>Поле контрольной суммы CRC, которое нужно для контроля целостности и отсутствия ошибок в кадре. Отправитель рассчитывает контрольную сумму на основе остальных данных кадра и прикладывает её внутри специального поля CRC. Получатель, после приёма, сам рассчитывает контрольную сумму и сравнивает её с приложенной.</span>
<span>Если значения не совпадают – данные некорректны.</span></p><blockquote><p><span>Поле CRC лишь выявляет факт ошибки в данных, но ни в коей мере не может помочь её исправить.</span></p></blockquote></li></ol><p><span>Также, перед каждым кадром станция-отправитель добавляет преамбулу. </span><strong><span>Преамбула</span></strong><span> – последовательность бит, определяющая начало кадра Ethernet. Стандартом определено, что она не является частью кадра Ethernet, и выполняет роль герольда: приход преамбулы заставляет толпу проснуться и ждать чего-то важного (то есть, самого кадра Ethernet).</span></p><blockquote><p><span>Преамбула состоит из восьми байтов: они представляют собой последовательность чередующихся единиц и нулей – это позволяет принимающему устройству настроить свой темп на темп передачи.</span></p><p><span>То есть, преамбула выглядит как </span><code>10101010 10101010 10101010 10101010 10101010 10101010 10101010 10101011</code><span>. Первые семь байт повторяют </span><code>10101010</code><span>, а в последнем заключительный символ – единица, как заключительное словцо в речи герольда.</span></p><p><span>&quot;Отличающийся&quot; восьмой байт принято называть </span><strong><span>начальным ограничителем</span></strong><span> или </span><strong><span>НО</span></strong><span>. Легко запоминается, так как аббревиатура является дочерней от </span><strong><span>Н</span></strong><span>еопознанное </span><strong><span>Л</span></strong><span>ошадиное </span><strong><span>О</span></strong><span>вно, и применяется к сетям в целом.</span></p></blockquote><p style="text-align: center;"><img src="https://drive.google.com/uc?export=view&amp;id=1m9JVCJjHa_YYTISvlh-v8y06x3IwA1uO" style=" zoom: 100%;"><b></b></p><p style="text-align: center;"><b>Формат кадра Ethernet</b></p><p></p><p><span>Интерфейс Ethernet и его протоколы приведены в сравнениях пунктов 15 и 16.</span></p><h2 id='13-технология-token-ring-основные-принципы-метод-доступа-формат-кадра-система-приоритетного-доступа'><span>13. Технология Token Ring: основные принципы, метод доступа, формат кадра, система приоритетного доступа</span></h2><p><img src="https://c.tenor.com/Lg21skpXtU4AAAAC/cat-meme.gif" style="zoom:50%;" /></p><p><span>Технология To</span><del><span>l</span></del><span>k</span><del><span>i</span></del><span>en Ring регулируется стандартом IEEE 802.5. Работает на канальном уровне, обладает свойствами отказоустойчивости (в отличие от Ethernet). </span></p><blockquote><p><span>Сети Token Ring работают с двумя битовыми скоростями - 4 Мб/с и 16 Мб/с. Первая скорость определена в стандарте 802.5, а вторая является новым стандартом де-факто, появившимся в результате развития технологии Token Ring.</span></p><p><span>Смешение станций, работающих на различных скоростях, в одном кольце не допускается.</span></p></blockquote><p><span style="color:RED"><strong><span>Token Ring переводится как &quot;маркерное кольцо&quot;, а не &quot;кольцоТолкиена&quot;</span></strong></span></p><p><span>Данная технология разрабатывалась как надёжная альтернатива Ethernet (не выгорело), и в настоящее время используется только маразматиками и путешественниками во времени.</span></p><p><strong><span>К общим характеристикам архитектуры сетей классического Token Ring можно отнести:</span></strong></p><ul><li><span>Доступ к среде передачи – маркерный метод или метод передачи права;</span></li><li><span>Обмен кадрами – широковещательный, с проверкой адресата;</span></li><li><span>Среда передачи – экранированная и неэкранированная витая пара, волоконно-оптический кабель;</span></li><li><span>Физическая топология – звезда;</span></li><li><span>Логическая топология – кольцо;</span></li><li><span>Сеть может строиться на основе нескольких колец, разделяемых мостами.</span></li></ul><p><span>Сеть Token-Ring представляет собой кольцевую топологию, где хосты присоединяются к сети через специальные концентраторы (как звезда, но не звезда). То есть, физически, сеть Token Ring – звёздно-кольцевая топология, а логически – кольцевая: каждый хост передаёт информацию одному соседнему хосту, а принимает – уже от другого.</span></p><p><span>Сам же концентратор не производит обработку информации – лишь централизует конфигурирование и контроль сети. Кольцо же рассматривается как общий разделяемый ресурс, контролируемый с помощью детерминируемого метода передачи права. </span><strong><span>Выглядит контроль следующим образом:</span></strong></p><ol start='' ><li><span>По кольцу постоянно двигаются пустые информационные кадры.</span></li><li><span>Когда хост получает или имеет сообщение для последующей передачи, он захватывает маркер, помещает в него сообщение и отправляет по сети;</span></li><li><span>Кадр проверяется каждым последовательным хостом;</span></li><li><span>Хост, который является местом назначения сообщения, копирует сообщение из кадра и изменяет маркер обратно на 0;</span></li><li><span>Когда кадр возвращается к отправителю, тот видит &quot;обнуление&quot; маркера – это означает, что сообщение было скопировано и получено;</span></li><li><span>Отправитель удаляет сообщение из кадра, а сам кадр продолжает циркулировать по сети – без сообщения он является пустым информационным кадром.</span></li></ol><blockquote><p><span>Работа сети Token Ring похожа на замкнутую реку (</span><em><span>опустим момент, что замкнутая река = озеро и вода в ней не движется, здесь вода движется</span></em><span>), по которой плавают бутылки для сообщений. Можно поместить своё сообщение в бутылку и отправить обратно в реку – у каждого получателя есть обезьянка для проверки новых сообщений.</span></p></blockquote><p><span>Сети Тоkеn Ring используют сложную систему приоритетов, которая позволяет хостам обладать более высоким приоритетом отправки сообщений, и соответственно чаще пользоваться сетью. Для этого, кадр содержит информацию о приоритете сообщения и поле резервирования. Так, маркер не могут захватить станции с приоритетом ниже чем у него. Резервирование же означает, что захваченный маркер не могут зарезервировать (для следующего прохода по сети) станции с приоритетом ниже чем у текущего отправителя.</span></p><p><strong><span>Плюсы:</span></strong></p><ul><li><span>Гарантированная доставка сообщений;</span></li><li><span>Высокая скорость.</span></li></ul><p><strong><span>Минусы:</span></strong></p><ul><li><span>Некропостинг (хватит выкапывать дедушку, он неактуален);</span></li><li><span>Необходимы дорогостоящие устройства доступа к сети;</span></li><li><span>Высокая сложность технологии реализации сети;</span></li><li><span>К каждому устройству необходимо тянуть 2 кабеля (для повышения надёжности): один входящий, другой исходящий от компьютера к концентратору;</span></li><li><span>Высокая стоимость (160-200% от Ethernet).</span></li></ul><p style="text-align: center;"><img src="https://drive.google.com/uc?export=view&amp;id=1UtdoY9qPqkCtHHB6QJpBrFSNQRgpzEL0" style=" zoom: 100%;"><b></b></p><p style="text-align: center;"><b>Что-то там по Token Ring</b></p><p></p><p><span>В сетях Token Ring используется три формата кадров:</span></p><ol start='' ><li><p><strong><span>Маркер.</span></strong><span> Длина – 3 байта.</span>
<span>Кадр специального формата и назначения, курсирующий по сети как бутылка по реке.</span>
<span>Состав:</span></p><ul><li><p><strong><span>Начальный ограничитель.</span></strong>
<span>Закодированная последовательность, шифром отличающаяся от шифра данных: так достигается их гарантированное различие.</span></p></li><li><p><strong><span>Управление доступом.</span></strong>
<span>Последовательность системной информации </span><code>PPP T M RRR</code><span>:</span></p><ul><li><code>P</code><span> – бит приоритета;</span></li><li><code>T</code><span> – бит маркера;</span></li><li><code>M</code><span> – бит монитора (нужна ли диагностика);</span></li><li><code>R</code><span> – бит резервирования (приоритет резервирования).</span></li></ul></li><li><p><strong><span>Конечный ограничитель.</span></strong>
<span>Финализатор, аналогичный ограничителю начала.</span></p></li></ul><figure><table><thead><tr><th style='text-align:center;' ><span>Начальный ограничитель</span></th><th style='text-align:center;' ><span>Управление доступом</span></th><th style='text-align:center;' ><span>Конечный ограничитель</span></th></tr></thead><tbody><tr><td style='text-align:center;' ><span>1 байт</span></td><td style='text-align:center;' ><span>1 байт</span></td><td style='text-align:center;' ><span>1 байт</span></td></tr></tbody></table></figure></li><li><p><strong><span>Кадр данных.</span></strong>
<span>Кадр для хранения данных, сравним с содержимым плывущей бутылки.</span></p><ul><li><span>Ограничитель начала </span><code>SD</code><span> от </span><code>Start Delimeter</code><span>;</span></li><li><span>Управление доступом </span><code>AC</code><span> от </span><code>Access Control</code><span>;</span></li><li><span>Управление кадром </span><code>FC</code><span> от </span><code>Frame Control</code><span>;</span></li><li><span>Адрес получателя </span><code>DA</code><span> от </span><code>Destination Address</code><span>;</span></li><li><span>Адрес отправителя </span><code>SA</code><span> от </span><code>Source Address</code><span>;</span></li><li><span>Данные </span><code>INFO</code><span> от </span><code>INFORMATION</code><span>;</span></li><li><span>Контроль кадра </span><code>FCS</code><span> от </span><code>Frame Check Sequence</code><span>;</span></li><li><span>Ограничитель конца </span><code>ED</code><span> от </span><code>End Delimeter</code><span>;</span></li><li><span>Статус кадра </span><code>FS</code><span> от </span><code>Frame Status</code><span>.</span></li></ul><figure><table><thead><tr><th style='text-align:center;' ><span>SD</span></th><th style='text-align:center;' ><span>AC</span></th><th style='text-align:center;' ><span>FC</span></th><th style='text-align:center;' ><span>DA</span></th><th style='text-align:center;' ><span>SA</span></th><th style='text-align:center;' ><span>INFO</span></th><th style='text-align:center;' ><span>FCS</span></th><th style='text-align:center;' ><span>ED</span></th><th style='text-align:center;' ><span>FS</span></th></tr></thead><tbody><tr><td style='text-align:center;' ><span>1</span></td><td style='text-align:center;' ><span>1</span></td><td style='text-align:center;' ><span>1</span></td><td style='text-align:center;' ><span>6</span></td><td style='text-align:center;' ><span>6</span></td><td style='text-align:center;' ><span>4500</span></td><td style='text-align:center;' ><span>4</span></td><td style='text-align:center;' ><span>1</span></td><td style='text-align:center;' ><span>1</span></td></tr></tbody></table></figure></li><li><p><strong><span>Прерывающая последовательность.</span></strong>
<span>Согласно единственной копипасте со студенческих сайтиков, прерывающая последовательность сигнализирует об отмене текущей передачи кадра или маркера. Может появиться в любом месте потока битов. Состоит из двух байтов, содержащих начальный ограничитель и конечный ограничитель.</span></p></li></ol><h2 id='14-технология-fddi-основные-принципы-метод-доступа-среды-передачи'><span>14. Технология FDDI: основные принципы, метод доступа, среды передачи</span></h2><p><img src="https://c.tenor.com/LIx6sZ68b1gAAAAC/cat-cats.gif" referrerpolicy="no-referrer"></p><p><span>Сеть </span><strong><span>FDDI</span></strong><span> – от английского Fiber Distributed Data Interface, что переводится как &quot;оптоволоконный распределённый интерфейс данных&quot;.</span></p><p><span>FDDI является стандартом, регулирующим передачу данных по волоконно-оптическому кабелю со скоростью до 100 Мбит/с. Стандарт основан на Token Ring, а его спецификации описаны в ANSI X3T9.5. Главные отличия от Token Ring заключатся в протоколах управления маркером и в структуре сети:</span></p><ul><li><span>В Token Ring станция, передающая кадры, удерживает маркер до тех пор, пока не получит подтверждение успешного получения всех отправленные пакеты. В FDDI же станция выпускает маркер непосредственно при окончании передачи кадра;</span></li><li><span>FDDI не использует приоритет и поля резервирования, которые Token Ring использует для выделения системных ресурсов;</span></li><li><span>Топология FDDI состоит из двух противоположно направленных логических колец, а топология Token Ring – из одного.</span></li></ul><p><span>Классический вариант сети FDDI строится на основе двух волоконно-оптических колец (двойного кольца), световой сигнал по которым распространяется в противоположных направлениях. Каждый узел подключаются на приём и передачу к обоим кольцам. Именно такая кольцевая физическая топология реализует основной способ повышения отка­зоустойчивости сети.</span></p><p><strong><span>К общим характеристикам архитектуры сетей классической FDDI можно отнести:</span></strong></p><ul><li><span>Среда передачи – волоконно-оптический кабель, либо экранированная витая пара;</span></li><li><span>Доступ к среде передачи – маркерный метод или метод логического кольца (метод кольцевых слотов);</span></li><li><span>Физическая топология – звезда, двойное кольцо;</span></li><li><span>Логическая топология – кольцо.</span></li></ul><p><span>В нормальном режиме работы данные идут от станции к станции только по одному из колец, которое называется первичным (primary). Для определённости направление движения данных в первичном кольце задано против часовой стрелки. Маршрут передачи данных отражает логическую топологию сети FDDI, которая всегда есть кольцо.</span></p><p><span>Все станции, кроме передающей и принимающей, осуществляют ретрансляцию данных и являются сквозными. Вторичное кольцо (secondary) является резервным и в нормальном режиме работы сети для передачи данных не используется, хотя по нему и осуществляется непрерывный контроль за целостностью кольца.</span></p><p><span>При отключении от питания одной из станций кольца не обрываются, а срабатывает механизм bypass – прямая передача по внутреннему оптическому каналу из порта в порт.</span></p><p style="text-align: center;"><img src="https://drive.google.com/uc?export=view&amp;id=18nnioruxEGUTBBXvzoT2txnAf4VBtGJf" style=" zoom: 100%;"><b></b></p><p style="text-align: center;"><b>Топология FDDI без и с обрывом</b></p><p></p><p><span>Кольца в сетях FDDI рассматриваются как общая разделяемая среда передачи данных, а сама работа сети основывается на детерминированном маркерном доступе к логическому кольцу. Сначала происходит инициализация кольца, в процессе которой в кольцо одной из станций испускается специальный укороченный пакет служебных данных – маркер (token). После того, как маркер стал циркулировать по кольцу, станции могут обмениваться информацией.</span></p><p><span>Управление доступом к среде MAC осуществляется на основе метода кольцевых слотов.</span></p><blockquote><p><strong><span>Метод кольцевых слотов:</span></strong></p><ul><li><span>Работает при наличии двухкольцевой топологии FDDI;</span></li><li><span>Базируется на оптоволокне;</span></li><li><span>Принцип как у метода передачи права, но по кольцу перемещается 2-8 маркеров;</span></li><li><span>Недостатков у топологии нет. Если какой-то узел отключается – происходит автосегментация и он выкидывается из сети.</span></li></ul></blockquote><p style="text-align: center;"><img src="https://drive.google.com/uc?export=view&amp;id=1XyZkXARBGTNOkKaCSScGGtWhfe3dOxWp" style=" zoom: 100%;"><b></b></p><p style="text-align: center;"><b>FDDI. Формат кадра и формат маркера</b></p><p></p><p><strong><span>Формат кадра:</span></strong></p><ul><li><span>PA – Преамбула (Preamble): 16 или более пустых символов.</span></li><li><span>SD – Стартовый разделитель (Starting Delimiter): Символы </span><code>J</code><span> и </span><code>K</code><span>.</span></li><li><span>FC – Frame Control: 2 символа, отвечающие за тип информации в поле INFO</span></li><li><span>DA – Адрес назначения (Destination Address): 12 символов, показывающие кому адресован кадр.</span></li><li><span>SA – Адрес источника (Source Address): 12 символов, показывающие адрес отправителя кадра.</span></li><li><span>INFO – Поле данных (Information Field): 0 до 4478 байтов информации.</span></li><li><span>FCS – Контрольная сумма (Frame Check Sequence): 8 символов CRC.</span></li><li><span>ED – Конечный разделитель (Ending Delimiter): символ </span><code>T</code><span>.</span></li><li><span>FS – Конец кадра (End of Frame Sequence): 3 символа индикатора.</span></li></ul><p><strong><span>Формат маркера:</span></strong></p><ul><li><span>PA – Преамбула (Preamble): 4 или более пустых символов.</span></li><li><span>SD – Стартовый разделитель (Starting Delimiter): Символы </span><code>J</code><span> и </span><code>K</code><span>.</span></li><li><span>FC – Frame Control: 2 символа, отвечающие за тип маркера.</span></li><li><span>ED – Конечный разделитель (Ending Delimiter): два символа </span><code>T</code><span>.</span></li></ul><p><strong><span>FC – </span><code>LCFFTTTT</code><span>:</span></strong></p><ul><li><code>L</code><span> – длина кадра;</span></li><li><code>C</code><span> – синхронный или асинхронный режим работы;</span></li><li><code>FF</code><span> – </span><code>MAC</code><span> или </span><code>LLC</code><span>.</span></li></ul><h2 id='15-технология-fast-ethernet-основные-принципы-отличия-от-ethernet-варианты-для-разных-сред-передачи-архитектура'><span>15. Технология Fast Ethernet: основные принципы, отличия от Ethernet, варианты для разных сред передачи, архитектура</span></h2><p><img src="https://c.tenor.com/B2G3qZWSHZsAAAAC/kitten-cat.gif" style="zoom:150%;" /></p><blockquote><p><span>Ethernet – технология передачи данных.</span>
<span>Fast Ethernet – набор стандартов для передачи данных по сети по технологии Ethernet.</span></p><p><span>Скорость первых версий Ethernet ограничена 10 Мбит/с.</span>
<span>Скорость Fast Ethernet может достигать 100 Мбит/с.</span></p></blockquote><p><span>В определённый момент, технология передачи данных Ethernet начала терять актуальность – скорости 10 Мбит/с стало недостаточно для решения задач передачи данных. Это привело к разработке новой спецификации более быстрых сетей.</span></p><p><span>Данная спецификация получила номер IEEE 802.3u, и её цель была сохранить 802.3 без изменений, но с увеличением скорости работы. Так появилось расширение стандарта 802.3, известное как Fast Ethernet.</span></p><blockquote><p><span>В Fast Ethernet и Ethernet одинаковы форматы кадров, интерфейсы и процедуры.</span></p><p><span>То есть, они используют один формат кадра, механизм доступа к среде CSMA/CD и топологию &quot;звезда&quot;. Сам кабель всё также следует правилу двух.</span></p></blockquote><p><span>Главное изменение – уменьшение времени передачи одного бита с 100 до 10 нс, что достигается за счёт удаления поддержки трешовых сетевых устройств типа &quot;BNC-коннекторов&quot; и прочей бабушкиной жести. В нём поддерживаются только концентраторы и коммутаторы.</span></p><p style="text-align: center;"><img src="https://drive.google.com/uc?export=view&amp;id=1vc-8YutqsIpKMsSuG7tE51qex86XUHNH" style=" zoom: 100%;"><b></b></p><p style="text-align: center;"><b>Архитектура Fast Ethernet</b></p><p></p><p><span>Fast Ethernet поддерживает следующие варианты для разных сред передач (крч кабели):</span></p><ol start='' ><li><p><strong><span>Витая пара (</span><code>100Base-T4</code><span>)</span></strong><span> с длиной сегмента 100м. Позволяет использовать неэкранированную витую пару категории 3.</span></p><blockquote><p><span>Неэкранированная витая пара категории 3 – это когда в одном кабеле идут пары проводов, которые просто лежат вместе.</span></p></blockquote></li><li><p><strong><span>Витая пара (</span><code>100Base-TX</code><span>)</span></strong><span> с длиной сегмента 100м. Даёт полный дуплекс при 100 Мбит/с.</span></p><blockquote><p><span>Витая пара категории 5 – это когда провода в каждой паре переплетены между собой, для понижения уровня магнитных помех.</span></p></blockquote></li><li><p><strong><span>Оптоволокно (</span><code>100Base-FX</code><span>)</span></strong><span> с длиной сегмента 2000м. Даёт полный дуплекс при 100 Мбит/с.</span></p><blockquote><p><span>Оптоволокно – специальный кабель для передачи оптических сигналов (фотонов).</span></p></blockquote></li></ol><blockquote><p><span>Переход на Fast Ethernet означает замену сетевой платы на компьютере, что не оценили пользователи.</span></p><p><span>По этой причине, стандарт предусматривает механизм &quot;</span><strong><span>автоматическое согласование</span></strong><span>&quot; – он позволяет двум станциям автоматически договориться об оптимальной скорости (10 или 100 Мбит) и дуплексном режиме (полный дуплекс или полудуплекс).</span></p><p><span>Большая часть аппаратуры Ethernet поддерживает и использует эту функцию для самонастройки. </span></p></blockquote><p style="text-align: center;"><img src="https://drive.google.com/uc?export=view&amp;id=1xAbO302Lhs8scUIqIes6xshpAHSv26XB" style=" zoom: 50%;"><b></b></p><p style="text-align: center;"><b>Сравнение Ethernet и Fast Ethernet</b></p><p></p><h2 id='16-технология-gigabit-ethernet-основные-принципы-отличия-от-ethernet-и-fast-ethernet-варианты-для-разных-сред-передачи-интерфейс-протоколы'><span>16. Технология Gigabit Ethernet: основные принципы, отличия от Ethernet и Fast Ethernet, варианты для разных сред передачи, интерфейс, протоколы</span></h2><p><img src="https://c.tenor.com/ZY20qdo9d5wAAAAC/kitten-cute.gif" style="zoom: 67%;" /></p><p><span>Спустя некоторое время после разработки Fast Ethernet, было разработано ещё одно расширение с аналогичной идеей – увеличить производительность в 10 раз, сохранив обратную совместимость со старыми сетями Ethernet.</span></p><p><span>Новый стандарт, регулируемый IEEE 802.3ab, также известен как Gigabit Ethernet. Формат кадра совпадает с форматом кадра Ethernet и Fast Ethernet, конфигурируется сеть по тому же принципу &quot;точка-точка&quot;, используется механизм доступа к среде CSMA/CD, а топология – &quot;звезда&quot;.</span></p><p style="text-align: center;"><img src="https://drive.google.com/uc?export=view&amp;id=18o7d4a2qIuQ-HJZWLR5gB1no6hL5nCOs" style=" zoom: 100%;"><b></b></p><p style="text-align: center;"><b>Архитектура Gigabit Ethernet</b></p><p></p><p><span>Аналогично работает и функция самонастройки (автоматическое согласование), но в ней теперь доступны скорости 10, 100 и 1000 Мбит/с. Также, нормальным режимом работы считается дуплекс (но поддерживается и полудуплекс, сети ведь разные бывают).</span></p><p><span>В Fast Ethernet кадр передаётся в 10 раз быстрее чем в Ethernet, а в Gigabit Ethernet – в 10 раз быстрее чем в Fast Ethernet. То есть, Gigabit Ethernet в 100 раз быстрее чем Ethernet, а значит – максимальную длину кабеля следует соответственно уменьшить в 100 раз: иначе шум достигает получателя быстрее чем заканчивается передача кадра.</span></p><p><span>Урезка максимальной длины кабеля с 2500м до 25м – непозволительная роскошь, и в стандарт были внесены изменения, позволяющие урезать максимальную длину лишь до 200м за счёт двух новых свойств:</span></p><ol start='' ><li><strong><span>Расширение носителя </span><code>carrier extension</code><span>.</span></strong>
<span>Аппаратура отправителя вставляет собственное поле заполнителя, растягивающее нормальный кадр до 512 байт. Заполнитель также удаляется аппаратурой на принимающей стороне, и для программного обеспечения разницы никакой нет.</span></li><li><strong><span>Пакетная передача кадров </span><code>frame bursting</code><span>.</span></strong>
<span>Отправитель может посылать не единичный кадр, а пакет из кадров. Так можно существенно оптимизировать отправку объёмов данных.</span></li></ol><p><span>Gigabit Ethernet поддерживает следующие варианты для разных сред передач (крч кабели):</span></p><ol start='' ><li><strong><span>Оптоволокно (</span><code>1000Base-SX</code><span>)</span></strong><span> с длиной сегмента 550 метров.</span>
<span>Многомодовое волокно.</span></li><li><strong><span>Оптоволокно (</span><code>1000Base-LX</code><span>)</span></strong><span> с длиной сегмента 5000 метров.</span>
<span>Одномодовое или многомодовое волокно.</span></li><li><strong><span>2 экранированные витые пары (</span><code>1000Base-CX</code><span>)</span></strong><span> с длиной сегмента 25 метров.</span>
<span>Экранированная витая пара.</span></li><li><strong><span>4 неэкранированные витые пары (</span><code>1000Base-T</code><span>)</span></strong><span> с длиной сегмента 100 метров.</span>
<span>Стандартная витая пара 5-й категории.</span></li></ol><h2 id='17-концентраторы-функции-варианты-конструктивного-исполнения-особенности-сетей-построенных-на-концентраторах'><span>17. Концентраторы: функции, варианты конструктивного исполнения. Особенности сетей, построенных на концентраторах</span></h2><p><img src="https://c.tenor.com/hHaVzeiH-hcAAAAC/imsickofwork-technologysu-x.gif" style="zoom:120%;" /></p><blockquote><p><span>Концентратор базируется на идее повторителя.</span></p></blockquote><p><span>Данные передаются по кабелям. Кабели – физическая среда передачи данных. У физической среды передачи данных есть ограничение: чем дальше от источника, тем слабее сигнал.</span></p><p><strong><span>Повторитель</span></strong><span> – устройство, которое на физическом уровне воспроизводит сигнал и отправляет его дальше: то есть, повторяет сигнал и фактически усиливает источник сигнала. Буквально воспроизводит биты сигнала.</span></p><p><span>Повторитель (в такой простейшей форме) имеет всего два порта: вход и выход.</span></p><blockquote><p><span>Костры в цепи сигнальных огней между Гондором и Роханом – повторители сигнала, но от каждого костра можно послать сигнал лишь на один костёр.</span></p></blockquote><p><span>Существуют многопортовые повторители, обладающие большим количеством портов – концентраторы.</span></p><p><strong><span>Концентратор</span></strong><span> – сетевое устройство для распространения сигнала в сети. Все приходящие на порт данные пересылаются на все другие порты концентратора.</span></p><p><span>Помимо функционала повторителя (усиление и распространение сигнала), фактически позволяет объединять устройства в сеть.</span></p><blockquote><p><span>Концентратор – продвинутая версия повторителя: теперь в зоне видимости костра можно зажечь дохрена других таких же костров (правило применяется к каждому костру на карте).</span></p></blockquote><p><span>Концентратор также имеет дополнительный функционал (с большой силой приходит большая ответственность за сеть):</span></p><ol start='' ><li><strong><span>Отключение порта.</span></strong><span> Концентратор может отключать некорректно работающие порты;</span></li><li><strong><span>Резервирование портов.</span></strong><span> Можно забить часть портов как резервные;</span></li><li><strong><span>Защита портов.</span></strong><span> Можно шифровать порты, либо присваивать порту MAC-адрес подключенной к нему станции.</span></li></ol><p><span>Концентраторы бывают разными:</span></p><ul><li><strong><span>Пассивные концентраторы.</span></strong><span> Тупо пересылают данные;</span></li><li><strong><span>Активные концентраторы.</span></strong><span> Перед ретрансляцией, данные анализируются на предмет ошибок, после чего концентратор пытается их пофиксить. Слабый сигнал может быть усилен;</span></li><li><strong><span>Гибридные концентраторы.</span></strong><span> Концентраторы, в которые можно подключить кабели разных типов.</span></li></ul><p><span>Таким образом, у сетей, построенных на основе концентраторов, есть ряд особенностей:</span></p><ol start='' ><li><span>На концентратор приходит сигнал и он его ретранслирует на все прочие порты;</span></li><li><span>Концентратор не может фильтровать сетевой трафик. В совокупности с пунктом 1, это может существенно нагружать сеть и приводить к её сбоям.</span></li></ol><h2 id='18-мосты-функции-алгоритм-работы-прозрачного-моста-достоинства-и-недостатки-мостов'><span>18. Мосты: функции, алгоритм работы прозрачного моста, достоинства и недостатки мостов</span></h2><p><img src="https://c.tenor.com/_515GtHhQHoAAAAd/door-hide.gif" style="zoom:50%;" /></p><p><span>Концентратор транслирует данные на все порты кроме входящего. Но, когда в сети устройств больше чем несколько, это приводит к огромной нагрузке. Следовательно, большие сети надо формировать через более продвинутые устройства.</span></p><p><strong><span>Мост</span></strong><span> – сетевое устройство для виртуального преобразования большой сети в сеть, формирующуюся из сегментов. Это как большой камень, разбитый на части и сцепленный наножвачкой.</span></p><p><span>Работает на канальном уровне: устройство может и должно работать с MAC-адресами, что невозможно на физическом уровне. Каждый порт моста закреплён под конкретный фрагмент сети – это позволяет не просто управлять отдельными мелкими сетями, но формировать из них большую.</span></p><blockquote><p><span>Мосты выполняют три важных функции: анализ, фильтрацию и пересылку.</span></p><p><span>Фактически, мост снижает трафик в сети путём разделения большой сети на фрагменты – он объединяет эти фрагменты и эффективно управляет ими, даже если у них отличаются протоколы на физическом или канальном уровне.</span></p></blockquote><p><strong><span>Чем мосты хороши:</span></strong></p><ol start='' ><li><span>Относительно просто и дёшево объединяют локальные сети;</span></li><li><span>&quot;Локальные&quot; кадры одной сети остаются в своём сегменте сети (никаких цыган в Индии);</span></li><li><span>Присутствие мостов прозрачно для пользователей;</span></li><li><span>Так как мосты объединяют локальные сети в логически единую сеть, то перемещение компьютера между этими сетями не требует изменения его сетевого адреса.</span></li></ol><p><strong><span>Чем мосты плохи:</span></strong></p><ol start='' ><li><span>Возводит путь в абсолют – из возможных путей всегда выибрается один (не поддерживает альтернативные пути);</span></li><li><span>Не может изолировать косячные сегменты сети (если у вас в комнате поселился Зигмунд Фрейд, то это навсегда);</span></li><li><span>Дополнительная задержка кадров;</span></li><li><span>Если передаётся кадр, адрес которого ещё не содержится в таблице моста, то он передаётся во все сегменты. То есть, мост может способствовать значительным всплескам трафика в сети.</span></li></ol><p><span>Мосты могут иметь разный принцип работы, но на практике выжил только прозрачный мост (только он работает с Ethernet). Остальные мосты базируются на идее прозрачного моста:</span></p><ol start='' ><li><p><strong><span>Прозрачный мост.</span></strong>
<span>Предназначен для объединения сетей с идентичными протоколами на канальном и физическом уровнях.</span>
<span>Присутствие и работа моста являются прозрачными для хостов сети.</span>
<span>Прозрачный мост является самообучающимся устройством – он для каждого подключенного сегмента автоматически строит таблицу с MAC-адресами и их портами (адресную таблицу). В сетевом контексте это означает одну большую сеть с единым сетевым адресом и разными MAC-адресами.</span>
<span>Пересылка данных внутри сегмента игнорируется мостом, а между разными сегментами – проводится им по адресной таблице (если нужного адреса не нашлось – рассылка всем).</span></p><p style="text-align: center;"><img src="https://drive.google.com/uc?export=view&amp;id=1iOBfy4mA3dB-uU7_f1jJK-RZdiWgX87k" style=" zoom: 20%;"><b></b></p><p style="text-align: center;"><b>Схема прозрачного моста</b></p><p></p></li><li><p><strong><span>Мост с маршрутизацией от источника.</span></strong>
<span>Применяется для соединения кольцевых топологий (Token Ring, FDDI): станция-отправитель помещает в посылаемый в другое кольцо кадр всю адресную информацию о промежуточных мостах и кольцах, которые должен пройти кадр перед тем, как попасть в кольцо, к которому подключена станция-получатель.</span>
<span>Данный мост функционирует на основе информации, формируемой станцией-отправителем, и хранимой в конверте кадра.</span></p><blockquote><p><span>Мост с маршрутизацией от источника не хранит базу данных с адресами, а берёт данные из кадра.</span></p></blockquote><p style="text-align: center;"><img src="https://drive.google.com/uc?export=view&amp;id=1Fj-MFXsLi4jT6RqCX9ezoiy4bWzJDPWQ" style=" zoom: 100%;"><b></b></p><p style="text-align: center;"><b>Схема маршрутизирующего моста</b></p><p></p></li><li><p><strong><span>Транслирующий мост.</span></strong>
<span>Предназначен для объединения сетей с разными протоколами на канальном и физическом уровнях.</span></p><blockquote><p><span>Объединение достигается за счёт манипулирования передаваемыми кадрами – в них заменяются заголовки и концевики на заголовки и концевики соответствующего протокола.</span></p></blockquote></li><li><p><strong><span>Инкапсулирующий мост.</span></strong>
<span>Предназначен для объединения сетей с одинаковыми протоколами канального и физического уровня через высокоскоростную магистральную сеть с другими протоколами.</span></p><blockquote><p><span>В инкапсулирующем мосте, сеть FDDI объединяет какие-нибудь другие сети, например сети Fast Ethernet.</span></p></blockquote></li></ol><h2 id='19-коммутаторы-функции-режимы-работы-архитектуры-ядра-коммутатора-варианты-конструктивного-исполнения'><span>19. Коммутаторы: функции, режимы работы, архитектуры ядра коммутатора, варианты конструктивного исполнения</span></h2><p><img src="https://c.tenor.com/MSYyrF-zU5MAAAAd/grumpy-mad.gif" style="zoom:80%;" /></p><p><span>Мосты делят большую сеть на сегменты, и составляют сеть из сегментов. Однако, в сетях часто нужен ещё один слой сегментации: когда разделяются не только сегменты сети, но и устройства (компудахтеры).</span></p><p><strong><span>Коммутатор</span></strong><span> – сетевое устройство, конструктивно выполненное в виде сетевого концентратора, и действующее как высокоскоростной многопортовый мост. У него есть встроенный механизм коммутации, с помощью которого локальные сети имеют широковещательное сегментирование, а рабочие станции – выделенную полосу пропускания к себе.</span></p><blockquote><p><span>То есть, коммутатор – концентратор с прибамбассами, который работает как высокоскоростной мост с кучей портов.</span></p><p><span>Коммутация у коммутаторов аппаратная, а у мостов – программная</span>
<span>Маршрутизация у коммутаторов аппаратная, а у маршрутизаторов – программная </span></p></blockquote><p><span>Коммутатор способен «запоминать» адрес каждого компьютера, подключённого к его портам и передавать данные на компьютер адресата.</span></p><blockquote><p><span>Управляемый коммутатор – коммутатор с микропроцессором, который может кастовать лютую дичь (узкоспециализированный компьютер)</span></p><p><span>Неуправляемый коммутатор – тупая штуковина без микропроцессора.</span></p></blockquote><p style="text-align: center;"><img src="https://drive.google.com/uc?export=view&amp;id=1DGshg6HxJYOZt_gAPvvgIC89LGvPgBVl" style=" zoom: 70%;"><b></b></p><p style="text-align: center;"><b>Структура коммутатора</b></p><p></p><p><strong><span>Коммутатор также работает на канальном уровне и может вытворять следующие фокусы:</span></strong></p><ul><li><span>Создание и поддержка виртуальных сетей;</span></li><li><span>Поддержка протоколов STP;</span></li><li><span>Маршрутизация кадров;</span></li><li><span>Фильтрация и контроль трафика;</span></li><li><span>Передача данных с порта на порт.</span></li></ul><p><strong><span>Коммутатор также имеет несколько режимов работы – о них слышал каждый школьник</span></strong><span>:</span></p><ul><li><p><strong><span>Полудуплексный режим работы.</span></strong>
<span>Одновременно лишь одно устройство может передавать данные.</span></p><blockquote><p><span>Односторонняя одновременная передача.</span></p></blockquote></li><li><p><strong><span>Дуплексный режим работы.</span></strong>
<span>Отправитель и получатель могут одновременно обмениваться данными.</span></p><blockquote><p><span>Двусторонняя одновременная передача.</span></p></blockquote></li></ul><p><span>Одним из основных компонентов всего коммутационного оборудования является </span><strong><span>коммутирующая матрица</span></strong><span> – она представляет собой чипсет, соединяющий множество входов с множеством выходов на основе фундаментальных технологий и принципов коммутации.</span></p><p><strong><span>Коммутирующая матрица выполняет три функции:</span></strong></p><ul><li><span>Переключает трафик с одного порта матрицы на другой, обеспечивая их равнозначность;</span></li><li><span>Предоставляет качество обслуживания (Quality of Service, QoS);</span></li><li><span>Обеспечивает отказоустойчивость.</span></li></ul><p><strong><span>Коммутатор может использовать одну из трёх схем взаимодействия своих блоков/модулей:</span></strong></p><ol start='' ><li><p><strong><span>Коммутатор с ядром на основе коммутационной матрицы.</span></strong></p><p><span>Порты связывают коммутационной матрицей. Это самый простой и быстрый способ организации взаимодействия процессоров портов – к  каждому из N входных портов подключается N выходных портов.</span>
<span>Данный способ означает возрастание сложности схемы пропорционально квадрату количества портов коммутаторов.</span></p><blockquote><p><strong><span>Плюсы:</span></strong></p><ol start='' ><li><span>Высокая скорость коммутации;</span></li><li><span>Структуру просто реализовать в микросхеме.</span></li></ol><p><strong><span>Минусы:</span></strong></p><ol start='' ><li><span>Нет буферизации данных внутри коммутационной матрицы – они накапливаются во входных портах;</span></li><li><span>Сложность наращивания числа коммутируемых портов.</span></li></ol></blockquote><p style="text-align: center;"><img src="https://drive.google.com/uc?export=view&amp;id=1BRHVd1GQsfPbMIpGZREkP_vfyYF_sLco" style=" zoom: 50%;"><b></b></p><p style="text-align: center;"><b>Коммутатор с коммутационной матрицей</b></p><p></p></li><li><p><strong><span>Коммутатор с ядром на основе общей шины.</span></strong>
<span>Порты связывают высокоскоростной шиной.</span>
<span>Передача осуществляется в режиме разделения времени – каждому порту выделяется своё время передачи.</span>
<span>Если скорость работы шины будет меньше чем суммарная скорость работы всех портов, то шина станет узким местом передачи данных – бутылочным горлышком фон Неймана</span></p><blockquote><p><strong><span>Плюсы:</span></strong></p><ol start='' ><li><span>Данные разбиваются на небольшие ячейки, что аннулирует задержку из-за начального ожидания доступности выходного порта.</span></li></ol><p><strong><span>Минусы:</span></strong></p><ol start='' ><li><span>Промежуточной буферизации нет.</span></li></ol></blockquote><p style="text-align: center;"><img src="https://drive.google.com/uc?export=view&amp;id=1Xc6Qo-ckKw8PG4Uw4kf_5xq1BsS0g5qX" style=" zoom: 50%;"><b></b></p><p style="text-align: center;"><b>Коммутатор с общей шиной</b></p><p></p></li><li><p><strong><span>Коммутатор с ядром на основе разделяемой памяти.</span></strong>
<span>Порты связывают двухвходовой разделяемой памятью.</span>
<span>Входные блоки процессоров портов соединяются с переключаемым входом разделяемой памяти, а выходные блоки этих же процессоров соединяются с переключаемым выходом этой памяти.</span>
<span>Переключением памяти управляет менеджер очередей выходных портов.</span></p><blockquote><p><strong><span>Плюсы:</span></strong></p><ol start='' ><li><span>Требования к размеру буферной памяти процессора порта снижены.</span></li></ol><p><strong><span>Минусы:</span></strong></p><ol start='' ><li><span>Память должна быть достаточно быстрой для поддержания скорости переписи данных между портами коммутатора.</span></li><li><span>Масштабируемость архитектуры ограничена количеством портов – иначе операции записи/чтения будут слишком медленными.</span></li></ol></blockquote><p style="text-align: center;"><img src="https://drive.google.com/uc?export=view&amp;id=1TJhPQN3ILn-AQfPxtkjN8jznxBvCf0jz" style=" zoom: 50%;"><b></b></p><p style="text-align: center;"><b>Коммутатор с разделяемой памятью</b></p><p></p></li></ol><p><strong><span>Коммутаторы также классифицируются по связи с уровнями модели OSI, на которых они работают:</span></strong></p><ul><li><p><strong><span>Коммутатор L1.</span></strong>
<span>Коммутатор уровня 1 (Layer 1) – просто концентратор. Работает на физическом уровне, когда информация передаётся сплошным потоком бит.</span></p></li><li><p><strong><span>Коммутатор L2.</span></strong>
<span>Коммутаторы L2 – почти все неуправляемые коммутаторы. Их задача – составление адресных таблиц в формате коммутационных таблиц. То есть, они банально обеспечивают коммутацию и передачу данных по MAC-адресу.</span></p><p><span>Используются для сегментации сети и объединения рабочих групп.</span></p><p><span>Плюсы:</span></p><ol start='' ><li><span>Прозрачность для протоколов верхнего уровня;</span></li><li><span>Уровни доступа фактически работают как мост;</span></li><li><span>Аппаратная поддержка коммутации второго уровня.</span></li></ol></li><li><p><strong><span>Коммутатор L2+ или L3 Lite.</span></strong>
<span>Коммутаторы промежуточного уровня L2+ – коммутаторы L2 с расширенным функционалом, который зависит от производителя. В некоторых источниках называются коммутаторами L2 с функциями L3.</span></p><p><span>Например, может быть добавлена поддержка статической маршрутизации, или дополнительные функции безопасности.</span></p></li><li><p><strong><span>Коммутатор L3.</span></strong>
<span>Коммутаторы L3 – устройства, работающие на 3-м уровне OSI (сетевом). Это управляемые коммутаторы, функционально идентичные (почти) маршрутизатору: главное отличие в маршрутизации, которая в коммутаторах выполняется аппаратно, а в маршрутизаторах – программно.</span></p><p><span>Отличительная фишка – функция IP-маршрутизации.</span></p><p><span>Основные функции:</span></p><ol start='' ><li><span>Определение оптимального пути при передаче данных через IP-маршрутизацию;</span></li><li><span>Управление широковещательным и многоадресным трафиком с поддержкой протокола STP для устранения логических петель;</span></li><li><span>Улучшенная фильтрация трафика с помощью сетевых протоколов;</span></li><li><span>IP-фрагментация датаграммы.</span></li></ol></li><li><p><strong><span>Коммутатор L4.</span></strong>
<span>Коммутаторы L4 – устройства, работающие на 4-м уровне OSI (транспортном).</span></p><p><span>Отличительная фишка – виртуализация и возможность работы с приложениями вроде Telnet и FTP.</span></p></li><li><p><strong><span>Многоуровневый коммутатор.</span></strong>
<span>Коммутатор, сочетающий в себе уровни L2, L3 и L4 коммутаторов. То есть, передача данных осуществляется на основе информации о:</span></p><ul><li><span>MAC-адресе назначения;</span></li><li><span>IP-адресе;</span></li><li><span>Типах протоколов в заголовке сетевого уровня;</span></li><li><span>Номере порта адресата/адресанта в заголовке транспортного уровня.</span></li></ul></li></ul><h2 id='20-маршрутизаторы'><span>20. Маршрутизаторы</span></h2><p><img src="https://c.tenor.com/ZIXvD3e9dt4AAAAC/cat-ignore.gif" style="zoom:80%;" /></p><p><strong><span>Маршрутизатор</span></strong><span> – устройство, работающее на сетевом уровне модели OSI, и обеспечивающее поиск пути от источника до получателя. Оно использует одну или более метрик для определения оптимального пути передачи сетевого трафика на основании информации сетевого уровня.</span></p><blockquote><p><span>Маршрутизатор умеет очень гибко управлять трафиком, но обладает сравнительно низкой производительностью, L3-коммутатор же обладает высокой производительностью, но практически ничего не умеет.</span></p></blockquote><h3 id='201-функции-маршрутизатора'><span>20.1 Функции маршрутизатора</span></h3><ul><li><span>Чтение заголовков пакетов сетевых протоколов;</span></li><li><span>Построение таблицы маршрутизации на основе протоколов маршрутизации;</span></li><li><span>Определении на еë основе маршрута;</span></li><li><span>Буферизация;</span></li><li><span>Фрагментация;</span></li><li><span>Фильтрация поступающих пакетов;</span></li><li><span>Поддержка сетевых интерфейсов.</span></li></ul><h3 id='202-структура-маршрутизатора'><span>20.2 Структура маршрутизатора</span></h3><p style="text-align: center;"><img src="https://drive.google.com/uc?export=view&amp;id=1x7mM35kA4mliy0VMhL76SmBxBUUO6yEH" style=" zoom: 80%;"><b></b></p><p style="text-align: center;"><b>Структурная схема маршрутизатора</b></p><p></p><p><span>Таблица маршрутизации может иметь следующий вид:</span></p><figure><table><thead><tr><th style='text-align:center;' ><span>IP-адрес назначения</span></th><th style='text-align:center;' ><span>Маска</span></th><th style='text-align:center;' ><span>IP-адрес следующего роутера</span></th><th style='text-align:center;' ><span>Метрика</span></th><th style='text-align:center;' ><span>Status</span></th><th style='text-align:center;' ><span>TTL</span></th><th style='text-align:center;' ><span>Кто составил запись</span></th></tr></thead><tbody><tr><td style='text-align:center;' ><span>10.20.10.30</span></td><td style='text-align:center;' ><span>255.0.0.0</span></td><td style='text-align:center;' ><span>10.20.0.5</span></td><td style='text-align:center;' ><span>7</span></td><td style='text-align:center;' ><span>Up down</span></td><td style='text-align:center;' ><span>120с</span><br><span>250с</span></td><td style='text-align:center;' ><span>Динамический</span><br><span>Статический</span></td></tr></tbody></table></figure><h2 id='21-коммутирующие-концентраторы-функции-область-применимости'><span>21. Коммутирующие концентраторы: функции, область применимости</span></h2><p><span style="color:RED"><strong><span>Н Е П О Н Я Т Н О Е    Г О В Н О</span><span>*</span></strong></span></p><p><span style="color:RED"><strong><span>*</span><span>Я не понимаю, что сюда можно писать – копипащу единственную статью. Enjoy and Fun</span></strong></span></p><p><img src="https://c.tenor.com/sVzKpWbd-qcAAAAd/good-morning-funny-animals.gif" style="zoom:80%;" /></p><p><strong><span>Коммутирующие концентраторы</span></strong><span> (</span><strong><span>Switched Hubs</span></strong><span>), они же коммутаторы или переключатели, мо­гут рассматриваться как простейший и очень быстрый мост. Они позволяют разделить единую сеть на несколько сетей для увеличения допустимого размера сети или для снижения нагрузки в отдель­ных ее частях. В отличие от мостов, коммутаторы не принимают пакеты, а только переправляют их из одной части сети в другую. Никакой обработки пакетов при этом не производится, поэтому ком­мутаторы не замедляют обмена по сети, но они не могут преобразовывать формат пакета и его про­токола. Коллизии коммутатором не ретранслируются, что также выгодно отличает его от репитер­ного концентратора.</span></p><p><strong><span>Коммутатор (switch)</span></strong><span> является многопортовым устройством канального уровня (второй уровень справочной модели OSI). Коммутатор «изучает» МАС-адреса и накапливает данные о них во внутренней таблице. Между автором кадра и предполагаемым получателем коммутатор создает временное соединение, по которому и передается кадр. В стандартной локальной сети, реализующей коммутируемую топологию, все соединения устанавливаются через коммутирующий концентратор (switching hub). Каждому порту, а, следовательно, и подключенному к порту устройству, выделена собственная полоса пропускания. Первоначально принцип действия коммутаторов основывался на передаче кадров в соответствии с МАС-адресами, однако технологический прогресс внес свои коррективы. Современные устройства в состоянии коммутировать ячейки (пакеты кадров, имеющие фиксированную длину и соответствующие второму уровню структуры передачи данных). Кроме того, коммутаторы поддерживают протоколы третьего уровня, а также распознают IP-адреса и физические порты коммутатора-концентратора.</span></p><h2 id='22-алгоритм-покрывающего-дерева-на-основе-протокола-stp'><span>22. Алгоритм покрывающего дерева на основе протокола STP</span></h2><p><img src="https://c.tenor.com/O-h718UvzWIAAAAd/hiding-introvert.gif" referrerpolicy="no-referrer"></p><p><span>В коммутаторах могут возникать петли. </span><strong><span>Петля</span></strong><span> – состояние в сети, при котором происходит бесконечная пересылка фреймов между коммутаторами, подключёнными в один и тот же сегмент сети.</span></p><p><span>У корневого коммутатора нет назначенных портов. Назначенных может быть несколько (но один на сегмент), а корневых - лишь один.</span></p><p><span>Петли решаются протоколом STP, суть которого сводится </span><strong><span>к следующему порядку определения мастер коммутатора:</span></strong></p><ul><li><span>Мастер коммутатор определяется по наименьшей приоритетности, причём у него все порты должны быть назначены;</span></li><li><span>Определяются корневые порты, в свою очередь определяемые у близлежащих портов коммутаторов (близлежащих к мастер коммутатору);</span></li><li><span>Определяются основные порты и резервные. Основные(назначенные) порты сначала определяются по приоритетности. Назначенных портов у коммутатора может быть несколько – 1 на каждый сегмент. Если по какой-то причине приоритетность портов одинакова, то назначенный порт выбирается по сумме наименьшей метрики, если сумма метрики тоже одинакова, то определяется по номеру порта.</span></li></ul><p><strong><span>Иными словами, для того чтобы устранить логическую петлю, существуют правила:</span></strong></p><ol start='' ><li><span>Сначала определяют по приоритетности: у кого приоритетность ниже, тому порт будет назначен. Если приоритетности совпадают, то:</span></li><li><span>Определяют по весу или стоимости пути;</span></li><li><span>Если приоритетность и вес совпадают, то определяют по номеру порта.</span></li></ol><h2 id='23-функции-сетевого-и-транспортного-уровней-и-их-взаимосвязь'><span>23. Функции сетевого и транспортного уровней и их взаимосвязь</span></h2><p><img src="https://c.tenor.com/2immeiuqWJkAAAAC/cat-sit.gif" referrerpolicy="no-referrer"></p><p><span>Сетевой уровень (3-й уровень OSI) предоставляет сервисы, позволяющие хостам обмениваться данными по сети. Так, его основными протоколами являются IPv4 и IPv6.</span></p><blockquote><p><span>Сетевой уровень выполняет маршрутизацию блоков данных через сеть. Именно он служит для образования единой транспортной системы</span><strong><span>,</span></strong><span> объединяющей несколько сетей одного или различных типов.</span></p></blockquote><p><span>Протоколы сетевого уровня реализуют функции выбора маршрутизации и типа коммутации. Сам же сетевой уровень включает в себя функции установления последовательного соединения через все звенья сети, а также специальный протокол (сигнальный) для определения маршрута передачи от одного объекта к другому.</span></p><p><span>Для этого, протоколы данного уровня выполняют четыре основных функции:</span></p><ul><li><strong><span>Адресация оконечных устройств.</span></strong>
<span>Хостам необходимо назначить уникальный IP-адрес для возможности их идентификации в сети;</span></li><li><strong><span>Инкапсуляция.</span></strong>
<span>Источник IP-пакета добавляет информацию заголовка IP, например IP-адрес узла источника (отправляющего) и узла назначения (получающего).</span></li><li><strong><span>Маршрутизация.</span></strong>
<span>Сетевой уровень предоставляет сервисы, с помощью которых пакеты направляются к узлу назначения в другой сети. Для этого, пакет должен быть обработан маршрутизатором – он выбирает пути для пакетов и направляет их к узлу назначения (это и есть маршрутизация).</span></li><li><strong><span>Деинкапсуляция.</span></strong>
<span>Получатель IP-пакета проверяет IP-заголовок пакета: IP-адрес назначения в нём должен совпадать с собственным IP-адресом устройства – тогда пакет, уже без заголовка IP, передаётся на транспортный уровень.</span></li></ul><p><span>На пути от отправителя к получателю, пакеты могут быть искажены или утеряны. Транспортный уровень обеспечивает протоколам верхних уровней передачу данных с той степенью надёжности, которая им требуется.</span></p><p><span>Основные функции транспортного уровня:</span></p><ul><li><p><strong><span>Отслеживание отдельных сеансов связи.</span></strong>
<span>Каждый набор данных, который передаётся по сети, считается сеансом связи и отслеживается отдельно.</span></p><blockquote><p><span>Транспортный уровень отвечает за поддержку и отслеживание таких сеансов связи: узел ведь может иметь несколько приложений, одновременно обменивающихся данными по сети.</span></p></blockquote></li><li><p><strong><span>Сегментация данных и обратная сборка сегментов.</span></strong>
<span>Так как в один пакет можно включить ограниченный объём данных, то они должны быть разделены на управляемые части.</span></p><blockquote><p><span>Транспортный уровень разделяет данные на сегменты, которые проще контролировать и предавать.</span></p></blockquote></li><li><p><strong><span>Добавление информации заголовка.</span></strong>
<span>Протокол транспортного уровня должен добавить к блоку данных свой заголовок, с помощью которого будут выполняться задача по управлению процессом передачи данных.</span></p><blockquote><p><span>Транспортный уровень гарантирует, что даже если на устройстве запущено несколько приложений, все они получат правильные данные.</span></p></blockquote></li><li><p><strong><span>Определение приложений.</span></strong>
<span>Транспортный уровень должен разделять и управлять каналами передачи данных с различными требованиями.</span>
<span>Так как каждому приложению нужно переслать правильные потоки данных, транспортный уровень должен уметь определять целевое приложение. Для этого, он оперирует номерами портов, которые назначаются каждому целевому программному процессу узла. Номера портов уникальны лишь в рамках узла.</span></p></li></ul><blockquote><p><span>Взаимодействие между сетевым и транспортным уровнем проще показать на аналогии российской курьерской службы. Сетевой уровень – яндекс навигатор, которому главное проложить маршрут. Неважно как – главное что бы путь был, а там и синие мандалорцы подтянутся.</span></p><p><span>Доставить груз через проложенную жопу должен обычный работяга </span><em><span>транспортный уровень</span></em><span>, которому координатор дал маршрут и указание &quot;важно доставить надёжно или быстро&quot; – конкретный протокол транспортного уровня.</span></p><p><span>Дорогу навигатор прокладывает довольно хреново – на ней ухабы, дохлые мечты и печеньки с изюмом. Грузовичок работяги может трясти на такой дороге, и часть груза он может прое…потерять. И вот тут в роль вступает указание по доставке:</span></p><ul><li><span>Если груз важно доставить надёжно (то есть целиком), то работяга по новой доставляет все потерянные части груза (нет, он не ищет их на дороге, а возвращается к отправителю и забирает их клонов);</span></li><li><span>Если груз важно доставить быстро – работяга жмёт педаль в пол и давит все встречные гремучие ивы, но доставляет пиццу в срок.</span></li></ul></blockquote><h2 id='24-понятие-составной-сети-принципы-маршрутизации-на-основе-протоколов-rip-ospf-bgp'><span>24. Понятие составной сети, принципы маршрутизации на основе протоколов RIP, OSPF, BGP</span></h2><p><img src="https://c.tenor.com/ddlqeaYniK0AAAAC/discord-cat-cat.gif" style="zoom:80%;" /></p><p><span>Сеть в общем случае рассматривается как совокупность нескольких сетей и называется </span><strong><span>составной сетью</span></strong><span> или </span><strong><span>интерсетью</span></strong><span> (internetwork или internet).</span></p><p><span>Сети, входящие в составную сеть, называются </span><strong><span>подсетями</span></strong><span> (subnet) или просто сетями.</span></p><p><span>Маршруты внутри сетей хранятся в специальных маршрутных таблицах – </span><strong><span>таблицах маршрутизации</span></strong><span>. Их можно составлять статически (вручную) или динамически (с помощью специальных протоколов).</span></p><blockquote><p><strong><span>Таблица маршрутизации</span></strong><span> – электронная таблица (файл) или база данных, хранящаяся на маршрутизаторе или сетевом компьютере, которая описывает соответствие между адресами назначения и интерфейсами, через которые следует отправить пакет данных до следующего маршрутизатора.</span></p><p><span>Таблица маршрутизации является простейшей формой правил маршрутизации.</span></p></blockquote><p><span>В динамической маршрутизации есть:</span></p><ul><li><strong><span>Протоколы маршрутизации (Routing Protocols).</span></strong>
<span>Протоколы, с помощью которых маршрутизаторы обмениваются маршрутной информацией и строят топологию.</span></li><li><strong><span>Маршрутизируемые протоколы (Routed Protocols).</span></strong>
<span>Протоколы, для которых строится маршрутная топология (например, IPv4 и IPv6).</span></li></ul><blockquote><p><span>Использование протоколов маршрутизации позволяет освободить человека от рутинного заполнения маршрутов, а систему – от человеческого фактора, дополнительно повышая её отказоустойчивость на основе отслеживания доступности сегментов сети.</span></p></blockquote><p><span>Протоколы маршрутизации можно разделить на внешние (</span><strong><span>EGP</span></strong><span> или </span><strong><span>Eterior Gateway Protocol</span></strong><span>) и внутренние (</span><strong><span>IGP</span></strong><span> или </span><strong><span>Interior Gateway Protocol</span></strong><span>). Внешние протоколы используются для соединения автономных сетей между собой, а внутренние – для соединения узлов внутри автономной сети.</span></p><p><span>Среди протоколов машрутизации особо выделяются три самых известных:</span></p><ol start='' ><li><p><strong><span>Внутренний протокол маршрутизации RIP – Routing Information Protocol.</span></strong>
<strong><span>Протокол маршрутной информации.</span></strong>
<span>Так как это внутренний протокол маршрутизации, то он нужен для маршрутизации в рамках одной локальной сети.</span>
<span>Является дистанционно-векторным, то есть работает по принципу &quot;рассылай таблицу маршрутизации ближним своим&quot;. Главной характеристикой служит </span><strong><span>метрика</span></strong><span> – числовой показатель, задающий предпочтительность маршрута (интуитивно сравнивается с расстоянием). В RIP метрикой служат жопы – количество маршрутизаторов до цели.</span></p><p style="text-align: center;"><img src="https://thumbs.gfycat.com/MemorableThinChipmunk-size_restricted.gif" style=" zoom: 100%;"><b></b></p><p style="text-align: center;"></p><p></p><p><span>RIP был первым протоколом маршрутизации и сейчас практически не используется. Его главная задача – вовремя обновлять все таблицы маршрутов в сети, посылая регулярные сообщения об их обновлении.</span></p><p><span>Сам процесс формирования таблиц маршрутизации построен следующим образом:</span></p><ul><li><span>Создание первичных маршрутных таблиц;</span></li><li><span>Рассылка первичных маршрутных таблиц соседям;</span></li><li><span>Получение RIP-сообщений от соседей и обработка этих сообщений;</span></li><li><span>Рассылка обновлённых маршрутных таблиц соседям;</span></li><li><span>Повторение цикла получения, обработки и рассылки.</span></li></ul><p><span>Процесс работы протокола RIP состоит в рассылке, получении и обработке векторов расстояний до IP-сетей, находящихся в области действия протокола, то есть в данной RIP-системе.</span></p><p><span>Периодически (раз в 30 секунд) каждый маршрутизатор посылает широковещательно копию своей маршрутной таблицы всем соседям-маршрутизаторам, с которыми связан непосредственно. Маршрутизатор-получатель просматривает таблицу. Если в таблице присутствует новый путь или сообщение о более коротком маршруте, или произошли изменения длин пути, эти изменения фиксируются получателем в своей маршрутной таблице.</span></p><p><strong><span>Плюсы протокола RIP:</span></strong></p><ul><li><span>Простой алгоритм;</span></li><li><span>Его знают почти все сливки сетевого общества (хотя по возрасту они уже сыр).</span></li></ul><p><strong><span>Минусы протокола RIP:</span></strong></p><ul><li><span>Не работает с адресами подсетей;</span></li><li><span>После сбоя связи в маршрутизаторе, требуется много времени для восстановления связи;</span></li><li><span>Очень легко образуются петли и зацикливания;</span></li><li><span>Не поддерживает больше 16-и маршрутизаторов в сети (то есть, 15 хопов);</span></li><li><span>Метрика учитывает только количество хопов, но не пропускную способность сети;</span></li><li><span>Из-за медленного распространения маршрутной информации по сети, система не поспевает за изменеиями;</span></li><li><span>Не поддерживает хранение резервных маршрутов.</span></li></ul><p><span>Часть этих минусов была исправлена в более новой версии RIPv2, но к делу это не относится.</span></p></li><li><p><strong><span>Внутренний протокол маршрутизации OSPF – Open Shortest Path First.</span></strong><span> </span>
<strong><span>Открытый алгоритм предпочтительного выбора кратчайшего маршрута.</span></strong>
<span>Тип протокола OSPF основан на технологии отслеживания состояния канала: при выборе маршрута важно не количество узлов, а скорость канала.</span></p><p><span>Базируется на алгоритме построения дерева кратчайших путей (SPF): для каждого маршрутизатора, граф сети преобразуется в дерево кратчайших путей, где корень – текущий маршрутизатор, а потомки – варианты маршрутизаторов, для которых кратчайший путь может быть найден.</span></p><p><strong><span>Принцип работы OSPF:</span></strong></p><ol start='' ><li><span>После включения маршрутизаторов, OSPF ищет непосредственно подключенных соседей и коннектится с ними.</span></li><li><span>После коннекта, соседи обмениваются друг с другом информацией о подключенных и доступных им сетях – они строят карту сети (топологию сети). Данная карта одинакова на всех маршрутизаторах.</span></li><li><span>На основе полученной информации, для каждого маршрутизатора запускается SPF алгоритм, рассчитывающий оптимальный маршрут к каждой сети. Данный процесс называеться конвергенцией и происходит очень быстро.</span></li></ol><p><strong><span>Плюсы OSPF:</span></strong></p><ul><li><span>Нет ограничений на размер сети;</span></li><li><span>В сторону одного узла может быть несколько маршрутов;</span></li><li><span>Поддерживает аутентификацию;</span></li><li><span>Высокая скорость составления маршрута.</span></li></ul><p><strong><span>Минусы OSPF:</span></strong></p><ul><li><span>Вытеснил RIP, олды недовольны;</span></li><li><span>Требует глубоких знаний о сложных сетях – на коленке уже не развернуть сеть из зиккуратов;</span></li><li><span>В сети есть только одна таблица машрутной информации – её хранит каждый маршрутизатор, но не как ссылку на некий объект, а как цельный массив данных. То есть, увеличивается объём необходимой памяти.</span></li></ul><blockquote><p><span>SPF протоколы не рассылают периодические обновления, как это делают векторные алгоритмы. Вместо этого они рассылают обновления каждые 30 минут, причём не всю базу данных, а лишь определённую часть, тем самым облегчая загрузку сети.</span></p><p><span>Если какой-нибудь интерфейс или маршрутизатор отключится, то будет немедленно сгенерировано обновление и все маршрутизаторы сразу же обновят свои таблицы маршрутизации.</span></p></blockquote></li><li><p><strong><span>Внеший протокол маршрутизации BGP – Border Gateway Protocol.</span></strong><span> </span>
<strong><span>Пограничный межсетевой протокол.</span></strong>
<span>Так как это внешний протокол маршрутизации, то он нужен для маршрутизации в рамках интернета. Является протоколом прикладного уровня.</span></p><p><span>Маршрутизаторы, использующие протокол BGP, обмениваются информацией о маршрутизации и доступности сетей. То есть, BGP призван обеспечивать передачу маршрутов между различными сетями. Любая контора, будь то яндекс или пятёрочка, используют BGP для подключения своих дата-центров к интернету.</span></p><p><strong><span>BGP является специальным протоколом:</span></strong></p><ul><li class='md-task-list-item task-list-item task-list-done' ><input type='checkbox' checked/><p><span>Легко масштабируется;</span></p></li><li class='md-task-list-item task-list-item task-list-done' ><input type='checkbox' checked/><p><span>Имеет защиту от образования петель;</span></p></li><li class='md-task-list-item task-list-item task-list-done' ><input type='checkbox' checked/><p><span>Включает систему управления приоритетами маршрутов;</span></p></li><li class='md-task-list-item task-list-item task-list-done' ><input type='checkbox' checked/><p><span>Обладает высокой стабильностью;</span></p></li><li class='md-task-list-item task-list-item task-list-done' ><input type='checkbox' checked/><p><span>Так как должен связывать автономные сети, то должен &quot;понимать&quot; чем эти автономные сети являются и как их различать;</span></p></li><li class='md-task-list-item task-list-item task-list-done' ><input type='checkbox' checked/><p><span>Является дистанционно-векторным, так как маршрутизатор должен выбирать маршрут до сети из нескольких предложенных, а не просчитывать весь интернет (а цепляются сети в интернет как раз через BGP).</span></p></li><li class='md-task-list-item task-list-item task-list-not-done' ><input type='checkbox' /><p><span>Принцип работы объясняется сетевиками с помощью довольно сложных концепций;</span></p></li><li class='md-task-list-item task-list-item task-list-not-done' ><input type='checkbox' /><p><span>Принцип работы я описывать здесь не буду.</span></p></li></ul><p><strong><span>У данного протокола есть также ряд особенностей:</span></strong></p><ul><li><span>В качестве транспортного протокола, BGP использует протокол TCP;</span></li><li><span>BGP использует метрики не для определения петель, а для управления сетевыми политиками (правилами сети), которые используются маршрутизаторами во время выбора пути;</span></li><li><span>BGP не использует специальные системы обнаружения соседей – они добавляются и настраиваются вручную;</span></li><li><span>BGP безразлична топология автономных сетей – ответственность за маршрутизацию внутри неё должны нести внутренние протоколы маршрутизации.</span></li></ul></li></ol><h2 id='25-алгоритмы-маршрутизации-и-их-классификация'><span>25. Алгоритмы маршрутизации и их классификация</span></h2><p><img src="https://c.tenor.com/YqQ-XQ11yksAAAAC/funny-animals-stuck.gif" referrerpolicy="no-referrer"></p><p><span>Основная функция сетевого уровня заключается в выборе маршрута для пакетов от начальной до конечной точки. Алгоритмы выбора маршрутов и используемые ими структуры данных являются значительной областью при проектировании сетевого уровня.</span></p><p><strong><span>Классификация по Будылдиной:</span></strong></p><ol start='' ><li><strong><span>Векторы расстояния (Беллмана-Форда)</span></strong><span>, где выбор пути осуществляется на основании количества шагов до станции назначения;</span></li><li><strong><span>Выбор кратчайшего пути по алгоритму Дейкстра</span></strong><span> (выбирается оптимальный маршрут из всех возможных, на основании графа);</span></li><li><strong><span>На основе политик</span></strong><span> (тоже векторный). Выбор маршрута осуществляется по количеству автономных систем до станции назначения.</span></li></ol><p><img src="https://c.tenor.com/aZMOFP1N5TEAAAAC/angry-cat-triggered.gif" style="zoom:80%;" /></p><p><span>Протоколы маршрутизации могут быть реализованы с помощью алгоритмов маршрутизации, которые классифицируются по следующим признакам:</span></p><ol start='' ><li><p><strong><span>Классификация по способу выбора наилучшего маршрута.</span></strong></p><ol start='' ><li><p><strong><span>Одношаговые алгоритмы маршрутизации.</span></strong>
<span>Каждый маршрутизатор при выборе маршрута определяет только одно звено этого маршрута. Ответственность только за один шаг маршрута.</span></p></li><li><p><strong><span>Многошаговые алгоритмы маршрутизации (маршрутизация от источника).</span></strong>
<span>Весь маршрут задаётся в уже отправленном пакете узлом источника.</span></p><blockquote><p><span>Самые перспективные алгоритмы данной классификации.</span></p></blockquote></li></ol></li><li><p><strong><span>Классификация по способу построения таблиц маршрутизации.</span></strong></p><ol start='' ><li><p><strong><span>Алгоритмы простой маршрутизации.</span></strong>
<span>Таблиц маршрутизации нет, либо они примитивные (не передают никакой маршрутной информации).</span></p><ol start='' ><li><p><strong><span>Алгоритмы случайной маршрутизации.</span></strong>
<span>Пакет посылается в случайном направлении.</span></p></li><li><p><strong><span>Алгоритмы заполнения (лавинная маршрутизация).</span></strong>
<span>Пакеты посылаются по всем возможным выходным направлениям и по всем возможным портам.</span></p><blockquote><p><span>Самые перспективные среди алгоритмов простой маршрутизации, но всё равно дно.</span></p></blockquote></li><li><p><strong><span>Алгоритмы скорейшей передачи (горячей картошки).</span></strong>
<span>Как только маршрутизатор получает пакет, он старается его быстрее отослать куда-нибудь.</span></p></li><li><p><strong><span>Алгоритмы кратчайшей очереди (наименьшей загрузки).</span></strong>
<span>Пакет пересылается на наименее загруженный порт.</span></p></li><li><p><strong><span>Алгоритм по предыдущему опыту.</span></strong>
<span>Таблица маршрутизации содержит только запись, дублирующую предыдущую передачу.</span></p></li></ol></li><li><p><strong><span>Алгоритмы фиксированной и статической маршрутизации.</span></strong>
<span>Данные алгоритмы заносятся администратором сети. Применяются для простейших сетей или в ознакомительных целях.</span></p></li><li><p><strong><span>Адаптивные алгоритмы (алгоритмы динамической маршрутизации).</span></strong>
<span>Построение таблиц маршрутизации автоматизировано, а сами алгоритмы адаптированы к изменениям сети.</span></p><blockquote><p><span>9 из 10 стоматологов рекомендуют алгоритмы динамической маршрутизации.</span></p></blockquote></li></ol></li><li><p><strong><span>Классификация по месту выбора маршрутов (по маршрутному решению).</span></strong></p><ol start='' ><li><p><strong><span>Изолированные алгоритмы (локальные).</span></strong>
<span>Между маршрутизаторами нет обмена маршрутной информацией. Каждый маршрутизатор выбирает маршрут на основании самостоятельно собранной информацией.</span></p></li><li><p><strong><span>Централизованные алгоритмы.</span></strong>
<span>Сетевой маршрутный центр осуществляет сбор маршрутной информации от маршрутизаторов. Данный центр получает </span><del><span>власть, которая не снилась его отцу,</span></del><span> ответственность за определение оптимальных маршрутов и сбор маршрутной информации.</span></p></li><li><p><strong><span>Распределённые алгоритмы.</span></strong>
<span>Все маршрутизаторы учавствуют в сборе и распространении маршрутной информации. Работа по выбору оптимального маршрута распределена между всеми маршрутизаторами.</span></p><blockquote><p><span>Самая распространённая категория.</span></p></blockquote></li></ol></li><li><p><strong><span>Классификация по виду информации, которой обмениваются маршрутизаторы.</span></strong></p><ol start='' ><li><p><strong><span>Дистанционно-векторные алгоритмы.</span></strong>
<span>Каждый маршрутизатор, с определённой периодичностью, распространяет соседям сообщение с адресами всех известных ему подсетей и метрику до них.</span></p><ul><li><span>Эти алгоритмы плохо адаптируются к отказам маршрутизаторов и появлению петель;</span></li><li><span>Информацию можно получить только от соседних маршрутизаторов.</span></li></ul></li><li><p><strong><span>Алгоритмы состояния связи.</span></strong>
<span>Обеспечивают каждый маршрутизатор информацией, достаточной для построения точного графа связей сети.</span>
<span>Фактически, во всей сети есть одна таблица маршрутизатора, но она хранится каждым маршрутизатором (то есть, хранится сам массив данных, а не ссылка на него).</span></p></li></ol></li></ol><h2 id='26-структура-ip-адреса-классы-адресов-маска-сети-бесклассовая-адресация'><span>26. Структура IP-адреса, классы адресов, маска сети. Бесклассовая адресация</span></h2><p><img src="https://c.tenor.com/i39K1COMe3oAAAAd/kitten-falls-kitten-stumbling.gif" style="zoom: 50%;" /></p><h3 id='261-характеристика-протокола-ip'><span>26.1 Характеристика протокола IP</span></h3><p><span>Протокол IP был разработан как протокол с низкой нагрузкой. Он обеспечивает только те функции, которые необходимы для доставки пакета от узла источника к узлу назначения по взаимосвязанной системе сетей. IP не предназначен для мониторинга и управления потоком пакетов. Эти функции, при необходимости, выполняются другими протоколами на других уровнях, в первую очередь – протоколом TCP на уровне 4.</span></p><p><strong><span>Основные характеристики IP:</span></strong></p><ul><li><p><strong><span>Без установления соединения.</span></strong>
<span>Перед отправкой пакетов данных соединение с хостом назначения не устанавливается.</span></p><blockquote><p><span>Обмен данными без установления соединения аналогичен отправке письма без предварительного уведомления получателя.</span></p></blockquote></li><li><p><strong><span>Негарантированная доставка.</span></strong>
<span>Протокол IP не гарантирует получение всех доставляемых пакетов.</span></p></li><li><p><strong><span>Независимость от среды.</span></strong>
<span>Канальный уровень в модели OSI отвечает за приём IP-пакета и его подготовку к транспортировке по среде передачи данных. Это означает, что пересылка пакетов IP не ограничивается какой-либо конкретной коммуникационной средой.</span></p></li></ul><h3 id='262-структура-адреса-на-примере-ipv4'><span>26.2 Структура адреса на примере IPv4</span></h3><p><span>Адрес IPv4 является иерархическим и состоит из раздела сети и раздела хоста. Определяя ту или иную часть, необходимо обращать внимание не на десятичное значение, а на 32-битную последовательность, как показано на рисунке.</span></p><p style="text-align: center;"><img src="https://drive.google.com/uc?export=view&amp;id=1J94cVgJOm5Hd3_L_mYBVZh-pnGGCp7G2" style=" zoom: 60%;"><b></b></p><p style="text-align: center;"><b>Структура IPv4 адреса</b></p><p></p><ul><li><span>Биты в сетевой части адреса должны быть одинаковыми у всех устройств, находящихся в одной сети;</span></li><li><span>Биты в хостовой части адреса должны быть уникальными для каждого хоста в сети;</span></li><li><span>Если два узла имеют одну битовую комбинацию в определенной сетевой части 32-битного потока, то эти два узла находятся в одной и той же сети.</span></li></ul><p><span>Узел может определить, какая часть 32-битного потока является сетевой, а какая узловой с помощью </span><strong><span>маски подсети</span></strong><span> – 32-битового значения, отделяющего сетевую часть адреса от хостовой части.</span></p><p><span>В битовой форме, маска подсети – непрерывная последовательность единиц, за которой следует непрерывная последовательность нулей. Последовательность единичных битов имеет длину сетевой части адреса, и именно так узел может разделить сетевую и хостовую части адреса.</span></p><p style="text-align: center;"><img src="https://drive.google.com/uc?export=view&amp;id=1Om10HxpFEP6vl9YBjLtbt1lGL2lu6FyM" style=" zoom: 60%;"><b></b></p><p style="text-align: center;"><b>Наглядное разделение частей маской</b></p><p></p><p><span>Идентификация сетевой и узловой частей IPv4 адреса происходит через побитовое применение операции &quot;логическое И&quot; к адресу и маске. То есть, маска под сети не содержит сетевой или узловой части IPv4-адреса; она лишь указывает компьютеру, где искать эти части в конкретном IPv4-адресе.</span></p><p style="text-align: center;"><img src="https://drive.google.com/uc?export=view&amp;id=1nhmIy1Mzc8M8SF34C-iLObGtsGmGOn9V" style=" zoom: 60%;"><b></b></p><p style="text-align: center;"><b>Выделение сетевой части IPv4 адреса</b></p><p></p><p><span>Маска имеет сокращённую форму: так как в ней главную роль играет непрерывная последовательность битовых единиц, начинающаяся со старшего разряда, то можно представлять маску просто как количество единичных битов. Например, адрес </span><code>192.168.0.13</code><span> и маску </span><code>255.255.128.0</code><span> (17 единиц подряд, в битовой форме) можно объединить как  </span><code>192.168.0.13/17</code><span>, где </span><code>/17</code><span> и есть сокращённая запись маски – </span><strong><span>длина префикса</span></strong><span>.</span></p><p><span>Сетевой адрес также называется </span><strong><span>префиксом</span></strong><span> или </span><strong><span>сетевым префиксом</span></strong><span>. Длина префикса означает количество бит, установленных в единицу (1) в маске подсети.</span></p><h3 id='263-классовая-адресация'><span>26.3 Классовая адресация</span></h3><p><span>На заре IPv4, адреса в интернете распределялись согласно классовой адресации стандарта RFC. Он разделяет одноадресные диапазоны на следующие классы:</span></p><ul><li><span>Класс A. Диапазон </span><code>от 0.0.0.0/8 до 127.0.0.0/8</code><span>. Разрабатывался для очень крупных сетей;</span></li><li><span>Класс B. Диапазон </span><code>от 128.0.0.0/16 до 191.255.0.0/16</code><span>. Разрабатывался для средних и крупных сетей;</span></li><li><span>Класс C. Диапазон </span><code>от 192.0.0.0/24 до 223.255.255.0/24</code><span>. Разрабатывался для небольших сетей;</span></li><li><span>Класс D. Диапазон </span><code>от 224.0.0.0 до 239.0.0.0</code><span>. Разрабатывался для многоадресных рассылок;</span></li><li><span>Класс E. Диапазон </span><code>от 240.0.0.0 до 255.0.0.0</code><span>. Разрабатывался для экспериментальных адресов.</span></li></ul><p><span>С появлением World Wide Web, классическая адресация перестала эффективно распределять ограниченное адресное пространство IPv4. Ей на смену пришла бесклассовая адресация – она игнорирует правила классов.</span></p><p><span>В то время, с ограниченным количеством компьютеров, использующих Интернет, классическая адресация была эффективным средством распределения адресов. Так, сети классов A и B имеют очень большое количество адресов узлов, а класс C имеет очень мало. На сети класса А приходится 50% сетей IPv4. Это привело к тому, что большинство доступных адресов IPv4 не используются.</span></p><h3 id='264-сегментирование-сетей'><span>26.4 Сегментирование сетей</span></h3><blockquote><p><strong><span>Сегментирование сети</span></strong><span> – разделение сети на подсети.</span></p></blockquote><p><span>Для создания IPv4-подсетей задействуются один или несколько бит из узловой части в качестве бит сетевой части. Для этого, расширяется маска подсети: биты заимствуются из узловой части адреса. Чем больше заимствовано бит из узловой части, тем больше подсетей можно создать. Чем больше бит, заимствованных для увеличения числа подсетей, тем меньше количество узлов в подсети.</span></p><p><span>Разделение сетей проще всего выполнить на границах октетов /8, /16 и /24. Важно помнить, что увеличение длины префикса сокращает число узлов в каждой подсети.</span></p><figure><table><thead><tr><th style='text-align:left;' ><strong><span>Длина префикса</span></strong></th><th style='text-align:left;' ><strong><span>Маска подсети</span></strong></th><th style='text-align:left;' ><strong><span>Маска подсети в двоичной системе (n = сеть, h = хост)</span></strong></th><th style='text-align:left;' ><strong><span># хостов</span></strong></th></tr></thead><tbody><tr><td style='text-align:left;' ><strong><span>/8</span></strong></td><td style='text-align:left;' ><strong><span>255</span></strong><span>.0.0.0</span></td><td style='text-align:left;' ><strong><code>nnnnnnnn</code></strong><code>.hhhhhhhh.hhhhhhhh.hhhhhhhh</code><span> </span><strong><code>11111111</code></strong><code>.00000000.00000000.00000000</code></td><td style='text-align:left;' ><span>16 777 214</span></td></tr><tr><td style='text-align:left;' ><strong><span>/16</span></strong></td><td style='text-align:left;' ><strong><span>255.255</span></strong><span>.0.0</span></td><td style='text-align:left;' ><strong><code>nnnnnnnn.nnnnnnnn</code></strong><code>.hhhhhhhh.hhhhhhhh</code><span> </span><strong><code>11111111.11111111</code></strong><code>.00000000.00000000</code></td><td style='text-align:left;' ><span>65 534</span></td></tr><tr><td style='text-align:left;' ><strong><span>/24</span></strong></td><td style='text-align:left;' ><strong><span>255.255.255</span></strong><span>.0</span></td><td style='text-align:left;' ><strong><code>nnnnnnnn.nnnnnnnn.nnnnnnnn</code></strong><code>.hhhhhhhh</code><span> </span><strong><code>11111111.11111111.11111111</code></strong><code>.00000000</code></td><td style='text-align:left;' ><span>254</span></td></tr></tbody></table></figure><p><span>Некоторые подсети проще, чем другие. Если требуется большее количество подсетей, необходимо использовать IPv4-сеть с большим числом бит в узловой части для заимствования. Например, адрес сети 172.16.0.0 имеет маску по умолчанию /16 или 255.255.0.0. Данный адрес имеет по 16 бит в сетевой и узловой части. 16 бит в узловой части можно использовать для создания подсетей.</span></p><p style="text-align: center;"><img src="https://drive.google.com/uc?export=view&amp;id=1KBrJHMqPJ2gB4bOufORXAd-ntEpQq2NP" style=" zoom: 80%;"><b></b></p><p style="text-align: center;"><b>Количество созданных подсетей</b></p><p></p><p><span>Стандартные схемы подсетей, вроде /16, создают подсети с одинаковым количеством узлов. Однако, не каждой создаваемой подсети потребуется столько хостов – по этой причине, многие занятые IPv4 адреса остаются неиспользуемыми.</span></p><p><span>Для решения этой проблемы была разработана </span><strong><span>маска подсети переменной длины (VLSM)</span></strong><span>.</span></p><p><span>Так, в предыдущем примере разделения на подсети, ко всем подсетям применялась одна маска подсети – то есть, все эти подсети содержали одинаковое число доступных адресов узлов.</span></p><blockquote><p><span>При традиционной схеме разделения сети на подсети, создаются подсети одинакового размера.</span></p></blockquote><p><span>VLSM же позволяет разделять пространство сети на неравные части – VLSM-маска подсети может варьироваться в зависимости от количества бит, которые были заимствованы для конкретной подсети. Эти биты образуют «переменную» часть маски.</span></p><p style="text-align: center;"><img src="https://drive.google.com/uc?export=view&amp;id=1wapzdZlihf_zWtQ8Pl9_O8W62Vx2Nfqv" style=" zoom: 60%;"><b></b></p><p style="text-align: center;"><b>Average базовый IPv4 и enjoyer VLSM</b></p><p></p><p><strong><span>Примечание</span></strong><span>: При использовании VLSM, всегда нужно начинать с обеспечения соответствия требованиям к узлам в крупнейших подсетях. Разбиение продолжается до тех пор, пока не будет удовлетворено требование к узлам в наименьшей подсети.</span></p><h3 id='265-что-не-так-с-ipv4'><span>26.5 Что не так с IPv4</span></h3><p><span>На протяжении многих лет разрабатывались дополнительные протоколы и процессы для решения новых задач. Тем не менее даже в результате изменений IPv4 по-прежнему имеет три основных недостатка.</span></p><ul><li><strong><span>Нехватка IP-адресов.</span></strong>
<span>IPv4 может предложить лишь ограниченное количество уникальных публичных IP4-адресов – примерно 4 миллиарда, чего недостаточно современному человечеству.</span></li><li><strong><span>Нехватка сквозных соединений.</span></strong>
<strong><span>Преобразование сетевых адресов (NAT)</span></strong><span> представляет собой технологию, которая  позволяет различным устройствам совместно использовать один публичный IPv4-адрес, скрывая адреса узлов внутри сети.</span>
<span>Это позволяет уменьшить количество используемых адресов, но может представлять проблему при использовании технологий, для которых необходимы сквозные соединения.</span></li><li><strong><span>Повышенная сложность сети.</span></strong>
<span>Хоть NAT и продлило срок службы IPv4, оно было предназначено лишь как механизм перехода на IPv6.</span>
<span>NAT в своей разнообразной реализации создает дополнительную сложность в сети, создавая задержку и затрудняя поиск и устранение неисправностей.</span></li></ul><h3 id='266-ipv6-да-придёт-спаситель'><span>26.6 IPv6: да придёт спаситель</span></h3><p><span>IPv6 помогает преодолеть ограничения протокола IPv4 и значительно расширяет доступные возможности, предлагая функции, которые оптимально соответствуют текущим и прогнозируемым сетевым требованиям.</span></p><p><span>К улучшениям, которые предлагает протокол IPv6, относятся следующие.</span></p><ul><li><strong><span>Расширенное адресное пространство.</span></strong>
<span>IPv6-адреса используют 128-битную иерархическую адресацию, в отличие от протокола IPv4, использующего 32 бита.</span></li><li><strong><span>Улучшенная обработка пакетов.</span></strong>
<span>Структура заголовка IPv6 была упрощена благодаря уменьшению количества полей.</span></li><li><strong><span>Отсутствие необходимости в использовании NAT.</span></strong>
<span>NAT был создан для временного разрешения нехватки адресов в IPv4, однако в IPv6 такой проблемы уже нет.</span></li></ul><p><span>32-битное адресное пространство IPv4 предусматривает примерно </span><code>4 294 967 296</code><span> уникальных адресов. Адресное пространство протокола IPv6 поддерживает </span><code>340 282 366 920 938 463 463 374 607 431 768 211 456</code><span> или 340 ундециллионов адресов. Примерно столько песчинок можно найти на всех пляжах нашей планеты.</span></p><p style="text-align: center;"><img src="https://drive.google.com/uc?export=view&amp;id=1g2tEXQYxnk1ypNYaxhyPLAy7l4z8513_" style=" zoom: 70%;"><b></b></p><p style="text-align: center;"><b>Пространство адресов IP</b></p><p></p><h2 id='27-формат-ip-пакета-их-маршрутизация-и-фрагментация'><span>27. Формат IP-пакета, их маршрутизация и фрагментация</span></h2><p><img src="https://c.tenor.com/qzimWk_DVYUAAAAd/cat-angry-angry.gif" style="zoom:50%;" /></p><h3 id='271-инкапсуляция-и-маршрутизация-ip'><span>27.1 Инкапсуляция и маршрутизация IP</span></h3><p><span>Протокол IP инкапсулирует сегмент транспортного уровня (уровень чуть выше сетевого уровня) или другие данные путем добавления заголовка IP. Заголовок протокола IP используется для доставки пакета на узел назначения.</span></p><p><span>Процесс инкапсуляции данных от уровня к уровню обеспечивает возможность разрабатывать и масштабировать сервисы на различных уровнях без влияния на другие уровни. То есть, сегменты транспортного уровня можно легко упаковать с помощью протоколов IPv4 или IPv6 или любого нового протокола, который может быть создан в будущем.</span></p><p><span>IP-заголовок проверяется устройствами уровня 3 (т.е. маршрутизаторами и коммутаторами уровня 3), когда он перемещается по сети к месту назначения.</span></p><blockquote><p><span>Информация об IP-адресации остается неизменной с момента выхода пакета с исходного хоста до момента его прибытия на хост назначения, за исключением случаев, когда она переводится устройством, выполняющим преобразование сетевых адресов (NAT) для IPv4.</span></p></blockquote><p><span>Маршрутизаторы реализуют протоколы маршрутизации для маршрутизации пакетов между сетями. Во время маршрутизации, выполняемой этими промежуточными устройствами, учитывается содержимое заголовка только того пакета, который инкапсулирует сегмент. Во всех остальных случаях часть данных пакета (т.е. инкапсулированная единица данных протокола (PDU) транспортного уровня) во время выполнения процессов на сетевом уровне остается неизменной.</span></p><blockquote><p><span>IP-пакет может фрагментироваться маршрутизаторами по мере необходимости. Ответственность за его сборку лежит на принимающей стороне.</span></p></blockquote><h3 id='272-формат-пакета-в-ipv4'><span>27.2 Формат пакета в IPv4</span></h3><p><span>IPv4 является одним из основных протоколов связи сетевого уровня. Заголовок пакета IPv4 используется для обеспечения доставки пакета на следующую остановку по пути к конечному устройству назначения.</span></p><p><span>Заголовок пакета IPv4 состоит из нескольких полей, включающих важную информацию о пакете. Эти поля содержат биты, которые анализируются процессом уровня 3 – значения каждого поля определяют различные параметры IP-пакета.</span></p><p><span>Среди наиболее важных полей в заголовке IPv4 можно выделить следующие:</span></p><ul><li><p><strong><span>Версия.</span></strong>
<span>4-битное двоичное значение, определяющее версию IP-пакета.</span>
<span>Для пакетов IPv4 в этом поле всегда указано значение 0100.</span></p></li><li><p><strong><span>Дифференцированные сервисы (Differentiated Services, DS).</span></strong>
<span>8-битное поле, используемое для определения приоритета каждого пакета.</span></p></li><li><p><strong><span>Контрольная сумма заголовка (CRC).</span></strong>
<span>Данное поле используется для обнаружения повреждения в заголовке IPv4.</span></p></li><li><p><strong><span>Время существования (Time-to-Live, TTL).</span></strong>
<span>8-битное двоичное значение, используемое для ограничения времени существования пакета.</span></p><blockquote><p><span>Отправитель пакета устанавливает начальное значение времени существования (TTL), которое уменьшается на единицу каждый раз при обработке пакета маршрутизатором.</span></p><p><span>Если значение в поле TTL уменьшается до нуля, маршрутизатор отбрасывает пакет и отправляет на IP-адрес источника сообщение о превышении времени протокола ICMP (управление сообщениями в сети).</span></p><p><span>Поскольку маршрутизатор уменьшает TTL каждого пакета, маршрутизатор также должен пересчитать контрольную сумму заголовка.</span></p></blockquote></li><li><p><strong><span>Протокол.</span></strong>
<span>Используется для определения протокола вышестоящего уровня.</span>
<span>8-битное двоичное значение, указывающее тип полезной нагрузки данных, которые переносит пакет – это позволяет сетевому уровню пересылать данные на соответствующий протокол более высокого уровня.</span></p></li><li><p><strong><span>IPv4-адрес источника.</span></strong>
<span>32-битное двоичное значение, которое представляет IPv4-адрес источника пакета. Всегда является уникальным адресом.</span></p></li><li><p><strong><span>IPv4-адрес назначения.</span></strong>
<span>32-битное двоичное значение, которое представляет IPv4-адрес назначения пакета. Адрес может быть одноадресной, многоадресной или широковещательной рассылкой.</span></p></li></ul><p><span>Два наиболее часто используемых поля – это IP-адрес источника и IP-адрес назначения. Они не меняются в процессе передачи от узла-отправителя к узлу-получателю, и определяют &quot;откуда поступил пакет и куда он направляется&quot;.</span></p><p style="text-align: center;"><img src="https://drive.google.com/uc?export=view&amp;id=1_DbY03DTLeqABEoEz-sveYhDIZlYSBcL" style=" zoom: 40%;"><b></b></p><p style="text-align: center;"><b>Формат IPv4-пакета</b></p><p></p><h3 id='273-формат-пакета-в-ipv6--не-нужно-но-может-помочь-бонусом'><span>27.3 Формат пакета в IPv6.  </span><em><span>НЕ НУЖНО, НО МОЖЕТ ПОМОЧЬ БОНУСОМ</span></em></h3><p><span>Одним из основных конструктивных улучшений протокола IPv6, по сравнению с IPv4, является упрощенный заголовок IPv6. Его длина в два раза больше (40 октетов против 20), однако содержит на 4 поля меньше (8 полей против 12), что позволяет более эффективно обрабатывать заголовки IPv6:</span></p><ul><li><p><strong><span>Версия.</span></strong>
<span>4-битное двоичное значение, определяющее версию IP-пакета.</span>
<span>Для пакетов IPv6 в этом поле всегда указано значение 0110.</span></p></li><li><p><strong><span>Класс трафика.</span></strong>
<span>8-битное поле, соответствующее полю «Дифференцированные услуги (DS)» в заголовке IPv4.</span></p></li><li><p><strong><span>Метка потока.</span></strong>
<span>20-битное поле, указывающее на то, что всем пакетам с одинаковыми метками потока назначается одинаковый тип обработки маршрутизаторами.</span></p></li><li><p><strong><span>Длина полезной нагрузки.</span></strong>
<span>16-битное поле, указывающее длину блока данных или полезной нагрузки пакета IPv6. Не включает длину заголовка IPv6, которая всегда фиксирована на 40 байтов.</span></p></li><li><p><strong><span>Следующий заголовок.</span></strong>
<span>8-битное поле, соответствующее полю «Протокол» в заголовке IPv4.</span>
<span>Указывает тип полезной нагрузки данных, которые переносит пакет, что позволяет сетевому уровню пересылать данные на соответствующий протокол более высокого уровня.</span></p></li><li><p><strong><span>Предел перехода.</span></strong>
<span>8-битное поле, заменяющее поле «Время существования» (TTL) в IPv4.</span></p><blockquote><p><span>Предел перехода уменьшается на единицу каждым маршрутизатором, пересылающим пакет.</span></p><p><span>Когда счетчик достигает значения 0, пакет отбрасывается и на отправляющий узел пересылается сообщение ICMPv6, которое означает, что пакет не достиг своего назначения, так как был превышен предел переходов.</span></p><p><span>В отличие от IPv4, IPv6 не включает контрольную сумму заголовка IPv6, так как эта функция уже выполняется канальным и транспортным уровнями.</span></p></blockquote></li><li><p><strong><span>IPv6-адрес источника.</span></strong>
<span>128-битное поле, определяющее IPv6-адрес хоста-отправителя.</span></p></li><li><p><strong><span>IPv6-адрес назначения.</span></strong>
<span>128-битное поле, определяющее IPv6-адрес хоста-получателя.</span></p></li></ul><p><span>В отличие от IPv4, маршрутизаторы не делят на части направленные IPv6-пакеты.</span></p><h2 id='28-протоколы-arp-и-rarp-функции-форматы-пакетов'><span>28. Протоколы ARP и RARP: функции, форматы пакетов</span></h2><p><img src="https://c.tenor.com/W8T7K5fVzoEAAAAd/cat-vaccum-cat-automatic.gif" style="zoom:50%;" /></p><h3 id='281-arp'><span>28.1 ARP</span></h3><p><span>Если в сети используется протокол связи IPv4, для сопоставления IPv4-адресов с MAC-адресами необходимо использовать </span><strong><span>ARP – протокол разрешения адресов</span></strong><span>.</span></p><blockquote><p><span>Протокол ARP позволяет, в рамках локальной сети, найти MAC-адрес нужного устройства по его IP адресу.</span></p></blockquote><p><span>Каждое IP-устройство в сети Ethernet имеет уникальный MAC-адрес Ethernet. Когда устройство отправляет кадр Ethernet, он содержит и MAC-адрес назначения (MAC-адрес сетевой платы Ethernet получателя) и MAC-адрес источника (MAC-адрес сетевой платы Ethernet отправителя).</span></p><p><span>Для отправки пакета другому хосту в той же локальной сети IPv4, отправитель должен знать адрес IPv4 и MAC-адрес устройства назначения. IPv4 адрес получателя либо известен, либо разрешается по имени устройства. Однако MAC-адрес необходимо дополнительно определить.</span></p><p><span>Устройство использует протокол разрешения адресов (ARP) для определения MAC-адреса назначения локального устройства, если известен IPv4-адрес.</span></p><p><strong><span>Протокол ARP выполняет две основные функции:</span></strong></p><ul><li><span>Сопоставление IPv4-адресов и МАС-адресов;</span></li><li><span>Ведение таблицы соответствий адресам IPv4 MAC-адресов.</span></li></ul><p><span>Когда пакет отправляется на канальный уровень для инкапсуляции в кадре Ethernet, устройство обращается к таблице в своей памяти, чтобы найти сопоставленный с IPv4-адресом MAC-адрес. Эта таблица хранится в ОЗУ и называется </span><strong><span>ARP-таблицей</span></strong><span> или </span><strong><span>ARP-кешем</span></strong><span>.</span></p><ul><li><span>Если IPv4-адрес назначения пакета находится в той же сети, что и IPv4-адрес источника, устройство ищет в таблице ARP IPv4-адрес назначения.</span></li><li><span>Если IPv4-адрес назначения пакета находится не в той же сети, что IPv4-адрес источника, устройство ищет в таблице ARP IPv4-адрес шлюза по умолчанию.</span></li></ul><p><span>Если устройство находит IPv4-адрес, то в качестве MAC-адреса в кадре используется соответствующий MAC-адрес. Если запись не найдена, устройство отправляет ARP-запрос.</span></p><p><span>Сообщения ARP-запроса инкапсулируются непосредственно в кадре Ethernet. Заголовок IPv4 отсутствует. ARP-запрос инкапсулируется в кадре Ethernet со следующей информацией в заголовке:</span></p><ul><li><p><strong><span>MAC-адрес назначения.</span></strong>
<span>Широковещательный адрес FF-FF-FF-FF-FF-FF, требующий принятия и обработки ARP-запроса всеми сетевыми интерфейсными платами Ethernet в локальной сети (LAN).</span></p><blockquote><p><span>ARP-запрос – широковещательная рассылка, ответ на которую должен прийти только от одного устройства в локальной сети (то есть, от устройства с нужным IP адресом).</span></p></blockquote></li><li><p><strong><span>MAC-адрес источника.</span></strong></p></li><li><p><strong><span>Тип.</span></strong>
<span>В сообщении ARP-запроса есть поле «Тип» со значением 0x806. Оно информирует принимающую сетевую плату о том, что поле данных должно обрабатываться протоколом ARP.</span></p></li></ul><p><span>У протокола ARP есть также ряд проблем, связанных с информационной безопасностью. Так, поскольку ARP-запрос является кадром широковещательной рассылки, его получают и обрабатывают все устройства в локальной сети. В свою очередь, это может привести не просто к большому скачку трафика (если сеть большая), но и к так называемому &quot;отравлению&quot; ARP-кэша, когда взломщик успевает отправить свой ARP-ответ (с нужным ему адресом) до ARP-ответа от истинного устройства. ARP внесёт только первый полученный адрес в таблицу, что позволит злоумышленнику получать чужие пакеты.</span></p><h3 id='282-rarp'><span>28.2 RARP</span></h3><p><span>Существует также протокол </span><strong><span>RARP – обратный протокол преобразования адресов</span></strong><span>.</span></p><p><span>Данный протокол, как следует из названия, является обратным ARP: он выполняет обратное отображение адресов, то есть преобразует аппаратный (MAC) адрес в IP-адрес.</span></p><p><span>Это протокол сетевого уровня, он применяется во время загрузки узла (например, компьютера), когда тот посылает групповое сообщение-запрос со своим физическим адресом. Сервер принимает это сообщение и просматривает свои таблицы (либо перенаправляет запрос куда-либо еще) в поисках соответствующего физическому IP-адреса. После обнаружения найденный адрес отсылается обратно на запросивший его узел.</span></p><p><span>Другие станции также могут &quot;слышать&quot; этот диалог (рассылка же широковещательная) и локально сохранить эту информацию в своих ARP-таблицах. RARP позволяет разделять IP-адреса между не часто используемыми хост-узлами. После использования каким-либо узлом IP-адреса он может быть освобожден и выдан другому узлу.</span></p><p><span>Протокол RARP предполагает наличие специального сервера, обслуживающего RARP-запросы и хранящего базу данных о соответствии аппаратных адресов протокольным.</span></p><h2 id='29-протокол-icmp-функции-формат-пакета-основные-типы-пакетов-дополнительный-вопрос'><span>29. Протокол ICMP: функции, формат пакета, основные типы пакетов. </span><em><span>ДОПОЛНИТЕЛЬНЫЙ ВОПРОС</span></em></h2><p><img src="https://c.tenor.com/DTjGghU34AsAAAAd/cats-angry.gif" style="zoom:50%;" /></p><p><span>В пакет протоколов, работающих на сетевом уровне, входит специальный протокол ICMP. Его основная задача – диагностика проблем со связностью сети: это определение того, может ли достичь пакет адреса назначения в установленное время.</span></p><p><span>То есть, назначение протокола ICMP заключается не в повышении надёжности протокола IP, а в предоставлении обратной связзи о проблемах, связанных с обработкой IP-пакетов в определённых условиях. ICMP-сообщения не являются обязательными, из-за соображений безопасности.</span></p><blockquote><p><span>Именно на базе ICMP работают такие утилиты как </span><code>ping</code><span> и </span><code>traceroute</code><span>.</span></p><ul><li><code>ping</code><span> – работник отеля, который по команде идёт к постояльцу и стучит ему в дверь с вопросом &quot;есть кто живой?&quot;.</span></li><li><code>traceroute</code><span> – утилита для полной трассивроки маршрута. Результатом её работы служит получение полного маршрута между текущим хостом и хостом назначения.</span></li></ul></blockquote><p><span>Данный протокол может использоваться с IP как v4 (тогда это ICMPv4), так и v6 (тогда это ICMPv6): разница лишь в том, что во втором случае он включает в себя дополнительные функциональные возможности.</span></p><p><span>ICMP-сообщения инкапсулируются и передаются в IP-пакетах. Сам же формат такого сообщения следующий:</span></p><ul><li><strong><span>Тип сообщения.</span></strong><span> </span><code>1 байт.</code>
<span>Поле, указывающее о произошедшем событии: какое требуется диагностическое действие, или же какая ошибка произошла.</span></li><li><strong><span>Код сообщения.</span></strong><span> </span><code>1 байт.</code>
<span>Код подробного описания типа ошибки, её причины или необходимого диагностического действия.</span></li><li><strong><span>Контрольная сумма.</span></strong><span> </span><code>2 байта.</code>
<span>CRC.</span></li></ul><p><span>Существует множество типов ICMP-сообщений и причин их отправки, однако общими для IPv4 и IPv6 являются следующие типы:</span></p><ul><li><p><strong><span>Достижимость узла.</span></strong><span> </span><code>Тип 0</code><span>.</span>
<span>Эхо-сообщение ICMP можно использовать для проверки доступности узла в IP-сети.</span>
<span>Локальный узел отправляет узлу эхо-запрос ICMP, и если нужный узел доступен – он отправляет эхо-ответ.</span></p></li><li><p><strong><span>Узел назначения или сервис недоступен.</span></strong><span> </span><code>Тип 3.</code>
<span>Когда узел или шлюз получает пакет, который не может доставить, он может использовать ICMP-сообщение </span><code>Destination Unreachable</code><span>, чтобы сообщить источнику о том, что узел назначения или сервис для этого пакета недоступен.</span>
<span>В данном сообщении, указывается код причины, по которой пакет не может быть доставлен. Например, для ICMPv4:</span></p><ol start='0' ><li><span>Сеть недоступна;</span></li><li><span>Узел недоступен;</span></li><li><span>Протокол недоступен;</span></li><li><span>Порт недоступен.</span></li></ol></li><li><p><strong><span>Превышен интервал ожидания.</span></strong><span> </span><code>Тип 11.</code>
<span>Маршрутизатор может использовать сообщение </span><code>Time Exceeded</code><span> в случае, когда значение поля </span><code>Time to Live</code><span> в IPv4-пакете было изменено на 0.</span>
<span>Маршрутизатор также может использовать сообщение </span><code>Hop Limit</code><span> в том случае, когда аналогичное </span><code>TTL</code><span> поле &quot;предел переходов&quot; IPv6-пакета было изменено на 0.</span></p></li></ul><h2 id='30-протокол-tcp-функции-формат-сегмента-и-область-применения'><span>30. Протокол TCP: функции, формат сегмента и область применения</span></h2><p><img src="https://c.tenor.com/eH-L7uAQ7ZUAAAAC/hello-hi.gif" referrerpolicy="no-referrer"></p><h3 id='301-характеристика-протокола-tcp'><span>30.1 Характеристика протокола TCP</span></h3><p><span>Протокол IP отвечает только за структуру, адресацию и маршрутизацию пакетов. Он не определяет способ доставки или передачи пакетов.</span></p><p><span>Протоколы транспортного уровня определяют способ передачи сообщений между узлами и отвечают за управление требованиями надежности передачи. На транспортном уровне действуют два протокола – TCP и UDP: их выбор зависит от требования приложения к надёжности передачи данных.</span></p><p style="text-align: center;"><img src="https://drive.google.com/uc?export=view&amp;id=1YVAXbN4x3MXznc7BntfmV8UcvV34wRht" style=" zoom: 70%;"><b></b></p><p style="text-align: center;"><b>Применение протоколов UDP и TCP</b></p><p></p><p><strong><span>TCP</span></strong><span>, также известный как </span><strong><span>протокол управления передачей</span></strong><span>, это надёжный и полнофункциональный протокол транспортного уровня, который обеспечивает передачу всех данных на узел назначения. Он включает в себя специальные поля, обеспечивающие доставку данных приложения. Однако, эти поля требуют дополнительной обработки как со стороны хоста-отправителя, так и со стороны хоста-получателя.</span></p><h3 id='302-сегментация-в-протоколе-tcp'><span>30.2 Сегментация в протоколе TCP</span></h3><p><span>Надёжность TCP обоснована простым фактом – в отличие от UDP, он нумерует все пакеты и повторно отправляет отброшенные (повторная отправка возможна как раз благодаря нумерации – так можно восстановить правильный порядок после доставки). Порядковый номер соответствует порядковому номеру первого байта данных сегмента TCP.</span></p><blockquote><p><span>Передача с использованием TCP аналогична отправке пакетов с трекингом, путь которых отслеживается от отправителя до получателя. Если заказ разбит на несколько частей, заказчик может зайти на веб-сайт транспортной компании и посмотреть порядок доставки.</span></p></blockquote><p><span>Сегменты TCP могут не дойти до места назначения, или поступать в неправильном порядке. Для расшифровки исходного сообщения, данные из полученных сегментов повторно собираются в изнальном порядке.</span></p><p><span>Примающий TCP-процесс помещает данные из сегмента в буфер приёма. Сегменты располагаются в соответствии с порядковыми номерами и после повторной сборки передаются на уровень приложений. Все сегменты, которые поступают с несоответствующими порядковыми номерами, сохраняются для последующей обработки. Затем, когда поступают сегменты с отсутствующими байтами, такие сегменты обрабатываются в правильном порядке.</span></p><p style="text-align: center;"><img src="https://drive.google.com/uc?export=view&amp;id=1iJAyz3oRMPvDtqCgq4MZY6p070sZU3-x" style=" zoom: 70%;"><b></b></p><p style="text-align: center;"><b>Доставка пакетов с помощью TCP: пакеты сегментируются</b></p><p></p><p><span>TCP обеспечивает надёжность и управление потоком, благодаря обеспечению следующих операций:</span></p><ul><li><span>Отслеживание количества сегментов, отправленных на тот или иной хост тем или иным приложением;</span></li><li><span>Подтверждение полученных данных;</span></li><li><span>Повторная передача сегментов с неподтверждёнными данными по истечении определённого времени ожидания;</span></li><li><span>Допустимость приёма данных, которые могут поступить в неправильном порядке;</span></li><li><span>Отправка данных со скоростью, приемлемой для получателя.</span></li></ul><p><span>Для поддержания состояния связи и отслеживания информации, TCP должен сначала установить соединение между отправителем и получателем.</span></p><blockquote><p><span>TCP является протоколом с установлением соединения.</span></p></blockquote><h3 id='303-функции-протокола-tcp'><span>30.3 Функции протокола TCP</span></h3><p><span>Кроме сегментации данных и их повторной сборки, протокол TCP обеспечивает ряд других функций:</span></p><ul><li><p><strong><span>Установление сессии.</span></strong>
<span>Перед пересылкой любого трафика протокол TCP согласовывает и настраивает постоянное соединение (сеанс) между устройством источника и устройством назначения.</span></p><blockquote><p><span>Сеанс позволяет устройствам согласовать объём трафика, который можно переслать в заданный момент времени, а также тщательно контролировать передачу данных между этими двумя устройствами.</span></p></blockquote></li><li><p><strong><span>Гарантия надёжной доставки.</span></strong>
<span>При передаче по сети, один из сегментов может быть повреждён или полностью утрачен. TCP обеспечивает гарантированную доставку на узел назначения всех сегментов данных, отправленных источником.</span></p></li><li><p><strong><span>Обеспечение доставки в нужном порядке.</span></strong>
<span>В сетях могут использоваться одновременно несколько маршрутов с разными скоростями передачи информации. Так как доставка пакетов может быть однвременной, то прибыть они могут в разном порядке.</span>
<span>Используя нумерацию и упорядочивание сегментов, TCP может гарантировать сборку пакетов в правильном порядке.</span></p></li><li><p><strong><span>Управление потоком передачи данных.</span></strong>
<span>Ресурсы сетевых узлов, такие как память или вычислительные мощности, ограничены. Когда протокол TCP получает информацию о том, что эти ресурсы используются слишком активно, он может потребовать от отправляющего приложения снизить скорость потока данных.</span></p></li></ul><h3 id='304-заголовок-протокола-tcp'><span>30.4 Заголовок протокола TCP</span></h3><p><span>Для отслеживания состояния сеанса связи протокол TCP фиксирует, какую информацию он отправил и какая информация была подтверждена.</span></p><p><span>Сегмент TCP добавляет 20 байт (160 бит) накладных расходов при инкапсуляции данных уровня приложения.</span></p><p><span>Таблица идентифицирует и описывает десять полей в заголовке TCP.</span></p><figure><table><thead><tr><th style='text-align:left;' ><strong><span>Поля заголовка TCP</span></strong></th><th style='text-align:left;' ><strong><span>Описание</span></strong></th></tr></thead><tbody><tr><td style='text-align:left;' ><strong><span>Порт источника</span></strong></td><td style='text-align:left;' ><span>16-битное поле, используемое для идентификации исходного приложения по номеру порта.</span></td></tr><tr><td style='text-align:left;' ><strong><span>Порт назначения</span></strong></td><td style='text-align:left;' ><span>16-битное поле, используемое для идентификации приложения назначения по номеру порта.</span></td></tr><tr><td style='text-align:left;' ><strong><span>Порядковый номер</span></strong></td><td style='text-align:left;' ><span>32-битное поле, используемое для пересборки данных.</span></td></tr><tr><td style='text-align:left;' ><strong><span>Номер подтверждения</span></strong></td><td style='text-align:left;' ><span>32-битное поле, используемое для указания того, что данные были получены, и следующий байт, ожидаемый от источника.</span></td></tr><tr><td style='text-align:left;' ><strong><span>Длина заголовка</span></strong></td><td style='text-align:left;' ><span>4-битное поле, известное как «смещение данных», которое указывает на длину заголовка сегмента TCP.</span></td></tr><tr><td style='text-align:left;' >&nbsp;</td><td style='text-align:left;' ><span>6-битное поле зарезервировано для использования в будущем.</span></td></tr><tr><td style='text-align:left;' ><strong><span>Управляющие биты</span></strong></td><td style='text-align:left;' ><span>Используемое 6-битное поле, включающее битовые коды или флаги, указывающие на назначение и функция сегмента TCP</span></td></tr><tr><td style='text-align:left;' ><strong><span>Размер окна</span></strong></td><td style='text-align:left;' ><span>16-битное поле, используемое для указания количества байтов, которые могут быть приняты за один момент.</span></td></tr><tr><td style='text-align:left;' ><strong><span>Контрольная сумма</span></strong></td><td style='text-align:left;' ><span>16-битное поле, используемое для проверки ошибок заголовка и данных датаграммы.</span></td></tr><tr><td style='text-align:left;' ><strong><span>Указатель срочности</span></strong></td><td style='text-align:left;' ><span>16-битное поле, используемое для указания срочности содержащихся данных.</span></td></tr></tbody></table></figure><p style="text-align: center;"><img src="https://drive.google.com/uc?export=view&amp;id=1u6n9YQu4ONE8ZqTEXxw3DdpPPo9C3B2w" style=" zoom: 40%;"><b></b></p><p style="text-align: center;"><b>Формат пакета TCP</b></p><p></p><p><span>Шесть бит в поле битов управления в заголовке сегмента TCP называются флагами. Каждый флаг представляет собой бит, который либо включен, либо выключен:</span></p><ul><li><strong><span>URG.</span></strong>
<span>Флаг «Указатель важности»;</span></li><li><strong><span>ACK.</span></strong>
<span>Флаг подтверждения, используемый при установке соединения и завершении сеанса;</span></li><li><strong><span>PSH.</span></strong>
<span>Флаг &quot;Push&quot;;</span></li><li><strong><span>RST.</span></strong>
<span>Флаг RST используется для сброса соединения при возникновении ошибки или в случае превышения времени ожидания;</span></li><li><strong><span>SYN.</span></strong>
<span>Синхронизирует порядковые номера, используемые при установке соединения;</span></li><li><strong><span>FIN.</span></strong>
<span>Больше нет данных от отправителя, используется при завершении сеанса.</span></li></ul><h3 id='305-приложения-использующие-протокол-tcp'><span>30.5 Приложения, использующие протокол TCP</span></h3><p><span>TCP является отличным пример того, как различные уровни набора протоколов TCP/IP могут выполнять определенные роли: данный протокол сам выполняет все задачи, связанные с разбиением потока данных на сегменты, обеспечением надёжности их передачи, управлением потоком и изменения порядка сегментов.</span></p><p><span>То есть, TCP освобождает приложение от необходимости брать на себя управление любой из этих задач. Ряд приложений может просто отправить поток данных протоколу транспортного уровня и использовать сервисы TCP, например:</span></p><ul><li><span>HTTP;</span></li><li><span>FTP;</span></li><li><span>SMTP;</span></li><li><span>SSH;</span></li><li><span>TCP-IP.</span></li></ul><h2 id='31-алгоритмы-управления-передачей-в-протоколе-tcp-и-их-параметры'><span>31. Алгоритмы управления передачей в протоколе TCP и их параметры</span></h2><p><img src="https://c.tenor.com/1cbzhT0TKTMAAAAd/cat-asleep.gif" style="zoom:67%;" /></p><h3 id='311-процессы-tcp-сервера'><span>31.1 Процессы TCP-сервера</span></h3><p><span>Каждый процесс приложения, работающий на сервере, использует специальный номер порта. Одинаковые номера не могут использоваться двумя различными службами на одном и том же сервере одного и того же порта с одинаковым протоколом транспортного уровня.</span></p><p><span>Активное серверное приложение, которому присвоен какой-либо определённый порт, считается открытым, что означает, что транспортный уровень может принимать и обрабатывать сегменты, направляемые на этот порт. Любой входящий запрос, который адресован правильному сокету, будет принят, а данные будут переданы приложению сервера. На сервере может быть одновременно открыто сразу несколько портов, по одному для каждого активного приложения сервера.</span></p><h3 id='312-установление-tcp-соединения'><span>31.2 Установление TCP-соединения</span></h3><p><span>В некоторых странах при встрече двух человек принято обмениваться рукопожатиями. Обе стороны понимают акт рукопожатия как сигнал для дружеского приветствия. Подключения в сети осуществляются аналогично. В соединениях TCP, клиент хоста устанавливает соединение с сервером, используя </span><strong><span>процесс тройного рукопожатия (трёхстороннего квитирования)</span></strong><span>.</span></p><ol start='' ><li><strong><span>SYN</span></strong><span>. Инициирующий клиент запрашивает сеанс связи типа «клиент-сервер» с сервером.</span></li><li><strong><span>SYN</span></strong><span>. Сервер подтверждает сеанс обмена данными «клиент-сервер».</span></li><li><strong><span>ACK</span></strong><span>. Инициирующий клиент подтверждает сеанс связи «сервер-клиент».</span></li></ol><p><span>Тройное рукопожатие подтверждает доступность узла назначения.</span></p><blockquote><p><span>Хост (SYN): серв, ты готов?</span></p><p><span>Серв (ACK): да бро, жду данные.</span></p><p><span>Хост (ACK): понял-понял.</span></p></blockquote><h3 id='313-закрытие-tcp-соединения'><span>31.3 Закрытие TCP-соединения</span></h3><p><span>Для прекращения соединения в заголовке сегмента должен быть установлен управляющий флаг Finish (FIN). Каждый односторонний TCP-сеанс завершается с помощью двойного рукопожатия, которое состоит из сегмента FIN и сегмента ACK (подтверждение).</span></p><ol start='' ><li><strong><span>FIN</span></strong><span>. Когда у клиента больше нет данных для отправки в потоке, он отправляет сегмент с установленным флагом FIN.</span></li><li><strong><span>ACK</span></strong><span>. Сервер отправляет подтверждение ACK, чтобы подтвердить получение FIN для завершения сеанса связи «клиент-сервер».</span></li><li><strong><span>FIN</span></strong><span>. Сервер отправляет клиенту флаг FIN для завершения сеанса связи между сервером и клиентом.</span></li><li><strong><span>ACK</span></strong><span>. Клиент отправляет в ответ флаг ACK, чтобы подтвердить получение флага FIN от сервера.</span></li></ol><p><span>После подтверждения всех сегментов, сеанс закрывается.</span></p><blockquote><p><span>Хост (FIN): серв, я всё отправил.</span></p><p><span>Серв (ACK): ок бро, понял.</span></p><p><span>Серв (FIN): я тогда пойду, приём окончен.</span></p><p><span>Хост (ACK): понял-понял, пока.</span></p></blockquote><h3 id='314-анализ-тройного-рукопожатия'><span>31.4 Анализ тройного рукопожатия</span></h3><p><span>Узлы отслеживают каждый сегмент данных, передаваемых во время сеанса, и обмениваются информацией о полученных данных с использованием сведений в заголовке TCP.</span></p><p><span>TCP является полнодуплексным протоколом, в котором каждое соединение представляет два односторонних потока обмена данными или сеанса. Для установления связи узлы используют тройное рукопожатие. Управляющие биты в заголовке TCP указывают на ход и состояние соединения.</span></p><p><strong><span>Основные функции тройного рукопожатия:</span></strong></p><ul><li><span>Определяет, присутствует ли в сети устройство назначения;</span></li><li><span>Проверяет, имеется ли на устройстве назначения активная служба и принимает ли она запросы на номер порта назначения, который инициирующий клиент планирует использовать;</span></li><li><span>Информирует устройство назначения, что клиент источника планирует установить сеанс связи на этом номере порта.</span></li></ul><p><span>По завершении обмена данными все сеансы закрываются, а соединение прерывается. Механизмы подключения и осуществления сеанса связи включают в себя функции TCP, обеспечивающие надёжность.</span></p><h2 id='32-протокол-udp-функции-формат-пакета-и-область-применения'><span>32. Протокол UDP: функции, формат пакета и область применения</span></h2><p><img src="https://c.tenor.com/N0aZdbie0N8AAAAd/cute-cute-cat.gif" style="zoom:50%;" /></p><h3 id='321-характеристика-протокола-udp'><span>32.1 Характеристика протокола UDP</span></h3><p><span>UDP – облегчённый транспортный протокол, который предлагает такую же сегментацию и повторную сборку данных, как и протокол TCP, но при этом не обеспечивает надёжность и управление потоком, присущие TCP.</span></p><p><span>UDP является настолько простым протоколом, что обычно описывается с точки зрения тех особенностей, которые отличают его от TCP:</span></p><ul><li><span>Данные восстанавливаются в том порядке, в котором получены;</span></li><li><span>Потерянные сегменты повторно не отправляются;</span></li><li><span>Работает без установления сеанса связи;</span></li><li><span>Работает без уведомления отправителя о доступности ресурса.</span></li></ul><p style="text-align: center;"><img src="https://drive.google.com/uc?export=view&amp;id=1VLMg1izPcmJRcneq7ii59QW7kaEuCiK5" style=" zoom: 70%;"><b></b></p><p style="text-align: center;"><b>Почему доставка протоколом UDP не является надёжной</b></p><p></p><h3 id='332-заголовок-протокола-udp'><span>33.2 Заголовок протокола UDP</span></h3><p><span>UDP является протоколом без отслеживания состояния (stateless): состояние сеанса связи не обеспечивается данным протоколом, работай он хоть на стороне клиента, хоть на стороне сервера. Если передача требует надёжности, то её должно обеспечивать само приложение.</span></p><p><span>Одно из главных требования для передачи видео/аудио данных по сети в режиме реального времени – наличие постоянного и высокоскоростного потока. Приложения для передачи таких данных допускают потери некоторого, незначительного, количества данных. Главное, чтобы доставка была быстрой и потери не были значительными – именно этим требованиям соответствует UDP.</span></p><p><span>Заголовок UDP намного проще, чем заголовок TCP, ввиду пониженных требований к надёжности доставки. По этой причине, он имеет только четыре поля и требует 8 байт (64 бита):</span></p><figure><table><thead><tr><th style='text-align:left;' ><strong><span>Поля заголовка UDP</span></strong></th><th style='text-align:left;' ><strong><span>Описание</span></strong></th></tr></thead><tbody><tr><td style='text-align:left;' ><strong><span>Порт источника</span></strong></td><td style='text-align:left;' ><span>16-битное поле, используемое для идентификации исходного приложения по номеру порта.</span></td></tr><tr><td style='text-align:left;' ><strong><span>Порт назначения</span></strong></td><td style='text-align:left;' ><span>16-битное поле, используемое для идентификации приложения назначения по номеру порта.</span></td></tr><tr><td style='text-align:left;' ><strong><span>Длина</span></strong></td><td style='text-align:left;' ><span>16-битное поле, указывающее длину заголовка датаграммы UDP.</span></td></tr><tr><td style='text-align:left;' ><strong><span>Контрольная сумма</span></strong></td><td style='text-align:left;' ><span>16-битное поле, используемое для проверки ошибок заголовка и данных датаграммы.</span></td></tr></tbody></table></figure><h3 id='334-приложения-использующие-протокол-udp'><span>33.4 Приложения, использующие протокол UDP</span></h3><p><span>Существуют три типа приложений, которые лучше всего подходят для работы с протоколом UDP:</span></p><ul><li><p><strong><span>Мультимедийные приложения и передача видео в режиме реального времени.</span></strong>
<span>Такие приложения могут допускать небольшие потери данных, но не допускают задержки (либо минимальные). Например, VoIP и потоковое видео.</span></p></li><li><p><strong><span>Простые приложения запросов и ответов.</span></strong>
<span>Приложения с простыми операциями, где хост отправляет запрос и может получить или не получить ответ. Например, DNS и DHCP.</span></p></li><li><p><strong><span>Приложения, самостоятельно обеспечивающие надежность передачи данных.</span></strong>
<span>Ненаправленный обмен данными, при котором некоторые функции не требуются, или обеспечиваются приложением. Например:</span></p><ul><li><span>Управление потоком;</span></li><li><span>Обнаружение ошибок;</span></li><li><span>Отправка подтверждений и восстановление после сбоев</span></li></ul></li></ul><p><strong><span>Приложения, требующие UDP:</span></strong></p><ul><li><span>DHCP;</span></li><li><span>DNS;</span></li><li><span>SNMP;</span></li><li><span>TFTP;</span></li><li><span>VoIP;</span></li><li><span>IPTV.</span></li></ul><h2 id='33-сети-hdlc'><span>33. Сети HDLC</span></h2><p><img src="https://c.tenor.com/QTarswjaNq4AAAAd/cat-bed-hair.gif" referrerpolicy="no-referrer"></p><p><strong><span>HDLS</span></strong><span> – </span><strong><span>протокол для закрытых сетей</span></strong><span>. Может работать в двух режимах:</span></p><ul><li><strong><span>Режим нормального ответа (РНО).</span></strong>
<span>Одна главная станция передаёт данные вторичным станциям, причём вторичные станции могут начать передачу только после разрешения первичной;</span></li><li><strong><span>Асинхронный сбалансированный режим (АСР).</span></strong>
<span>Станции имеют равные права и каждая из них реализует функции как первичной, так и вторичной.</span></li></ul><p><span>Формат кадра HDLC: | Флаг | Адресное поле | Управляющее поле | Данные | FCS |</span></p><p style="text-align: center;"><img src="https://drive.google.com/uc?export=view&amp;id=1ozPN0jzR-nG7yCbaWgL357fAQd_5O12b" style=" zoom: 50%;"><b></b></p><p style="text-align: center;"><b>Формат кадра HDLC</b></p><p></p><p><span>На управляющее поле отводится 8 бит, а само оно состоит из трёх кадров:</span></p><ul><li><p><strong><span>I-кадр.</span></strong><span> Информационный кадр, несëт в себе информацию. 1-й бит определяет идентификатор кадра. 2-4 биты означают N(S), то есть порядковый номер кадра, передаваемого от первичной станции к вторичной. 6-8 биты означают порядковый номер кадра, передаваемого от противоположной станции. 5-й бит (бит опроса) во всех кадрах имеет вид </span><code>P\F</code><span>:</span></p><ul><li><mjx-container class="MathJax" jax="SVG" style="position: relative;"><svg xmlns="http://www.w3.org/2000/svg" width="5.286ex" height="1.946ex" role="img" focusable="false" viewBox="0 -666 2336.6 860" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" style="vertical-align: -0.439ex;"><defs><path id="MJX-1-TEX-I-1D45D" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"></path><path id="MJX-1-TEX-N-3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path><path id="MJX-1-TEX-N-30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D45D" xlink:href="#MJX-1-TEX-I-1D45D"></use></g><g data-mml-node="mo" transform="translate(780.8,0)"><use data-c="3D" xlink:href="#MJX-1-TEX-N-3D"></use></g><g data-mml-node="mn" transform="translate(1836.6,0)"><use data-c="30" xlink:href="#MJX-1-TEX-N-30"></use></g></g></g></svg><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>p</mi><mo>=</mo><mn>0</mn></math></mjx-assistive-mml></mjx-container><script type="math/tex">p=0</script><span>, значит нет опроса/завершения;</span></li><li><mjx-container class="MathJax" jax="SVG" style="position: relative;"><svg xmlns="http://www.w3.org/2000/svg" width="5.286ex" height="1.946ex" role="img" focusable="false" viewBox="0 -666 2336.6 860" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" style="vertical-align: -0.439ex;"><defs><path id="MJX-2-TEX-I-1D45D" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"></path><path id="MJX-2-TEX-N-3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path><path id="MJX-2-TEX-N-31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D45D" xlink:href="#MJX-2-TEX-I-1D45D"></use></g><g data-mml-node="mo" transform="translate(780.8,0)"><use data-c="3D" xlink:href="#MJX-2-TEX-N-3D"></use></g><g data-mml-node="mn" transform="translate(1836.6,0)"><use data-c="31" xlink:href="#MJX-2-TEX-N-31"></use></g></g></g></svg><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>p</mi><mo>=</mo><mn>1</mn></math></mjx-assistive-mml></mjx-container><script type="math/tex">p=1</script><span>, значит идёт запрос на подтверждение;</span></li><li><mjx-container class="MathJax" jax="SVG" style="position: relative;"><svg xmlns="http://www.w3.org/2000/svg" width="5.843ex" height="1.724ex" role="img" focusable="false" viewBox="0 -680 2582.6 762" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" style="vertical-align: -0.186ex;"><defs><path id="MJX-3-TEX-I-1D439" d="M48 1Q31 1 31 11Q31 13 34 25Q38 41 42 43T65 46Q92 46 125 49Q139 52 144 61Q146 66 215 342T285 622Q285 629 281 629Q273 632 228 634H197Q191 640 191 642T193 659Q197 676 203 680H742Q749 676 749 669Q749 664 736 557T722 447Q720 440 702 440H690Q683 445 683 453Q683 454 686 477T689 530Q689 560 682 579T663 610T626 626T575 633T503 634H480Q398 633 393 631Q388 629 386 623Q385 622 352 492L320 363H375Q378 363 398 363T426 364T448 367T472 374T489 386Q502 398 511 419T524 457T529 475Q532 480 548 480H560Q567 475 567 470Q567 467 536 339T502 207Q500 200 482 200H470Q463 206 463 212Q463 215 468 234T473 274Q473 303 453 310T364 317H309L277 190Q245 66 245 60Q245 46 334 46H359Q365 40 365 39T363 19Q359 6 353 0H336Q295 2 185 2Q120 2 86 2T48 1Z"></path><path id="MJX-3-TEX-N-3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path><path id="MJX-3-TEX-N-31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D439" xlink:href="#MJX-3-TEX-I-1D439"></use></g><g data-mml-node="mo" transform="translate(1026.8,0)"><use data-c="3D" xlink:href="#MJX-3-TEX-N-3D"></use></g><g data-mml-node="mn" transform="translate(2082.6,0)"><use data-c="31" xlink:href="#MJX-3-TEX-N-31"></use></g></g></g></svg><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>F</mi><mo>=</mo><mn>1</mn></math></mjx-assistive-mml></mjx-container><script type="math/tex">F=1</script><span> передаётся в конце ответа, означает конец передачи.</span></li></ul></li><li><p><strong><span>S-кадр.</span></strong><span> Супервизор для восстановления кадров,потерянных из-за искажений в канале. 1-2 биты определяют идентификатор S-кадра. 6-8 биты означают возврат к номеру повреждённого кадра. 3-4 биты (S) – команды управления:</span></p><ul><li><span>00 – готов к приёму следующего кадра (ГП). То есть, станция (которая отправила этот кадр) готова к приёма следующего кадра. Используется в режимах РНО и АСР;</span></li><li><span>10 – не готов к приёму следующего кадра (НГП). То есть, станция временно (до посылки кадра ГП) не может принимать I-кадры и запрет остается в силе до посылки кадра ГП. Используется в режимах РНО и АСР;</span></li><li><span>01 – выборочный отказ (ВОТК). Означает запрос повторной передачи всех I-кадров, начиная с того номера, где произошла ошибка. Используется только в режиме АСР;</span></li><li><span>11 – отказ (ОТК). Нужно передавать все кадры, начиная с того, с которой произошла ошибка. Позволяет запросить передачу только одного I-кадра с номером N(R). Используется только в режиме АСР.</span></li></ul></li><li><p><strong><span>U-кадр.</span></strong><span> Ненумерованный кадр, предназначен для установления соединения и разъединения сеанса связей. 1-2 биты – идентификатор кадра. 3-4 и 6-8 биты – виды модификаторов.</span></p></li></ul><h2 id='34-принцип-работы-протокола-mpls-задачи-и-способы-организации-lsp'><span>34. Принцип работы протокола MPLS, задачи и способы организации LSP</span></h2><p><img src="https://c.tenor.com/7TRVO3SkQhAAAAAd/cat-cats.gif" style="zoom: 67%;" /></p><p><strong><span>MPLS</span></strong><span> или </span><strong><span>MutiProtocol Label Switching (мультипротокольная коммутация меток)</span></strong><span> – технология (протокол) быстрой коммутации пакетов в многопротокольных сетях, основанная на использовании меток. Разрабатывается и позиционируется как способ построения высокоскоростных IP-магистралей, но фактически распространяется на трафик любого маршрутизируемого сетевого протокола.</span></p><blockquote><p><span>MPLS является протоколом для ускорения и формирования потоков сетевого трафика.</span></p><p><span>С его помощью, пакеты данных сортируются на основе приоритетов – так можно увеличить пропускную способность для критически важных приложений, гарантируя им максимально доступную степень бесперебойной работы.</span></p></blockquote><p><span>Суть MPLS состоит в присвоении пакету специальной метки, по которой происходит пересылка (вместо адреса). Для этого, к пакету сетевого уровня добавляется (в начало) заголовок MPLS.</span></p><p><span>MPLS технология, с помощью протокола LDP, присваивает метку всем IP-пакетам, а тем временем уже сами маршрутизаторы принимают решение о передаче пакета далее на следующее устройство благодаря нужному значению метки.</span></p><p><span>Метки распределяются при конфигурировании сети, и обычно их назначение осуществляет вышестоящий маршрутизатор всем нижестоящим: так достигается уникальность всех меток. Если в сеть подключается новое устройство, нижестоящее устройство спрашивает о нëм у вышестоящих, после чего происходит перераспределение меток.</span></p><blockquote><p><span>Метка добавляется в составе MPLS заголовка, который добавляется между заголовком кадра (второй уровень OSI) и заголовком пакета (третий уровень OSI) и, по сути, в дальнейшем идет их наложение друг на друга.</span></p><p><span>Фактически, MPLS заголовок расположен на 2.5 уровне OSI, как раз из-за его расположенности между заголовками канального и сетевого уровней. Соответственно, сам протокол тоже не зависит от обоих этих уровней.</span></p></blockquote><p><strong><span>В заголовок MPLS входят четыре поля:</span></strong></p><ul><li><p><strong><span>Метка.</span></strong>
<span>Короткий айдишник фиксированной длины, определяющий класс сетевого уровня.</span>
<span>По значению метки осуществляется коммутация.</span></p></li><li><p><strong><span>Качество обслуживания (CoS).</span></strong>
<span>Экспериментальное поле, описывающее класс обслуживания пакета QoS (от класса зависит приоритетность – видео и аудио трафик будут передаваться с большим приоритетом).</span></p></li><li><p><strong><span>S.</span></strong><span> Признак дна стека меток.</span>
<span>В MPLS существует концепция стека меток. Она заключается в простой возможности иметь в пакете более одной метки, погружая их в формате стека (для сохранения инкапсуляции). Собственно, метки можно помещать </span><code>push</code><span> в стек, удалять </span><code>delete</code><span> или доставать </span><code>pop</code><span>.</span>
<span>В заголовке последней (т.е. самой глубокой или нижней) метки бит S=1, а во всех остальных метках в стеке бит S=0.</span></p><p style="text-align: center;"><img src="https://drive.google.com/uc?export=view&amp;id=1a7nfbuuX4KwAhmePLCnXtXIRyQUrl9mk"><b></b></p><p style="text-align: center;"><b>Стек из нескольких меток</b></p><p></p></li><li><p><strong><span>Время жизни (TTL).</span></strong>
<span>Значение, отображающее, сколько ещё раз пакет может быть отправлен.</span></p></li></ul><p style="text-align: center;"><img src="https://drive.google.com/uc?export=view&amp;id=1_gWS1QW-W3A3lrSA8c3vkKVLzM0wiNkp"><b></b></p><p style="text-align: center;"><b>Формат кадра MPLS</b></p><p></p><p><span>Помимо стека меток, в MPLS есть ещё несколько значимых определений:</span></p><ul><li><p><strong><span>LSR или Label Switched Router.</span></strong>
<span>Любой маршрутизатор в сети. Выполняет некие операции с метками, что отражено в названии.</span></p></li><li><p><strong><span>LER или Label Edge Router.</span></strong>
<span>Маршрутизатор на границе сети MPLS. Если взять путь, то LER маршрутизатор будет тем что кладёт первую метку в стек (</span><code>Ingress LSR</code><span>), и тем что начинает доставать метки из стека (</span><code>Egress LSR</code><span>).</span></p></li><li><p><strong><span>LSP или Label Switched Path.</span></strong>
<span>Путь переключения меток. Является однонаправленным каналом от </span><code>Ingress LSR</code><span> до </span><code>Egress LSR</code><span>.</span></p></li><li><p><strong><span>FEC или Forwarding Equivalence Class.</span></strong>
<span>Классы трафика. В такой класс входят пакеты, не только идущие по одному и тому же маршруту, но и обслуживаемые по одному классу.</span></p><blockquote><p><span>Пакеты одного FEC не обязаны следовать на один и тот же адрес назначения.</span></p><p><span>Если два пакета следуют в одно место, не обязательно они будут принадлежать одному FEC.</span></p></blockquote><p><span>FEC воспринимаются при пересылке одинаково.</span></p><p><span>FEC может учитывать разные параметры:</span></p><ol start='' ><li><span>IP-адрес назначения или источника;</span></li><li><span>Метки QoS;</span></li><li><span>Идентификатор VPN;</span></li><li><span>Тип приложений.</span></li></ol></li></ul><p><strong><span>Основные задачи MPLS:</span></strong></p><ol start='' ><li><span>Система меток значительно снижает время необходимое на поиск IP-маршрутизации;</span></li><li><span>Позволяет осуществлять точный поиск совпадений с самым длинным префиксом, что снижает ресурс обращения к памяти для маршрутизации одного пакета;</span></li><li><span>Точные совпадения на основе меток намного проще реализовать в оборудовании при меньшей нагрузке на него;</span></li><li><span>Даёт возможность контролировать, где и как трафик распределен в сети, чтобы управлять пропускной способностью, расставлять приоритеты для различных сервисов и предотвращать перегрузку оборудования.</span></li></ol><blockquote><p><span>MPLS работает поверх IP-сети, не заменяя её, а дополняя и улучшая.</span></p></blockquote><p><span>LSP можно создать двумя способами:</span></p><ol start='' ><li><p><strong><span>Явная маршрутизация.</span></strong></p><blockquote><p><span>Маршрутизаторы передают пакет в соответствии с указаниями, полученными от верхнего в данном тракте LSR.</span></p></blockquote><p><span>Обычные хосты и маршрутизаторы не могут взаимодействовать с MPLS метками, однако их нужно прикреплять к пакетам и обрабатывать их. Это происходит в тот момент, когда пакет достигает границы MPLS-сети. LER проверяет IP-адрес назначения и другие поля, определяя, по какому MPLS-пути должен пойти пакет, и присваивает пакету соответствующую метку. По ней пакет передается в сети MPLS. На другой границе MPLS-сети метка уже не нужна, и она удаляется, после чего IP-пакет становится открытым для другой сети.</span></p><p style="text-align: center;"><img src="https://drive.google.com/uc?export=view&amp;id=1uHKl9k1VOJ4vRF4YGaJWDbumJ18eur0Q"><b></b></p><p style="text-align: center;"><b>Передача пакета через MPLS-сеть</b></p><p></p></li><li><p><strong><span>Пошаговая маршрутизация Hop-by-hop.</span></strong></p><blockquote><p><span>Каждый маршрутизатор самостоятельно выбирает дальнейший путь следования пакета.</span></p></blockquote></li></ol><p><span>Также стоит отметить, что есть два основных способа сохранения меток:</span></p><ol start='' ><li><strong><span>Либеральный.</span></strong>
<span>Маршрутизатор сохраняет все метки, даже которые прошли через него транзитом.</span></li><li><strong><span>Консервативный.</span></strong>
<span>Маршрутизатор сохраняет только метки близлежайших устройств.</span></li></ol><h2 id='35-dhcp'><span>35. DHCP</span></h2><p><img src="https://c.tenor.com/aDUpEUMrA84AAAAd/cat-monkey.gif" style="zoom:67%;" /></p><p><strong><span>DHCP</span></strong><span> или </span><strong><span>протокол динамической настройки узла</span></strong><span>. Протокол прикладного уровня.</span></p><blockquote><p><span>Динамически назначает IP-адреса для повторного использования, когда они больше не нужны.</span></p></blockquote><p><span>Данный протокол позволяет компьютерам автоматически получать IP-адрес и другие параметры, необходимые для работы в сети.</span></p><p><span>IP-адрес можно назначать вручную каждому компьютеру в локальной сети. Но в больших сетях это очень трудозатратно, к тому же, чем больше локальная сеть, тем выше возрастает вероятность ошибки при настройке. Поэтому для автоматизации назначения IP был создан протокол DHCP.</span></p><p><span>Принцип работы DHCP сводится к </span><strong><span>DORA</span></strong><span> – </span><strong><span>D</span></strong><span>iscovery -&gt; </span><strong><span>O</span></strong><span>ffer -&gt; </span><strong><span>R</span></strong><span>equest -&gt; </span><strong><span>A</span></strong><span>cknowledgement.</span></p><ul><li><strong><span>Discovery (поиск).</span></strong>
<span>Когда клиент находится в инициализации, у нет нет IP-адреса. Об этом он сообщает через широковещательную рассылку специального сообщения </span><code>DHCPDISCOVER</code><span> во все устройства локальной сети.</span></li><li><strong><span>Offer (предложение).</span></strong>
<span>DHCP-сервер (например, маршрутизатор) слышит поиск и отвечает на него предложением IP-адреса, который может подойти клиенту. Предложение отправляется широковещательной рассылкой сообщения </span><code>DHCPOFFER</code><span>.</span></li><li><strong><span>Request (запрос).</span></strong>
<span>Клиент получает </span><code>DHCPOFFER</code><span>, а затем отправляет на сервер сообщение </span><code>DHCPREQUEST</code><span>.</span>
<span>Так он принимает адрес и уведомляет об этом DHCP-сервер.</span></li><li><strong><span>Acknowledgement (подтверждение).</span></strong>
<span>Сервер получает от клиента </span><code>DHCPREQUEST</code><span> и окончательно подтверждает передачу IP-адреса клиенту сообщением </span><code>DHCPACK</code><span>. Это широковещательное или прямое сообщение утверждает не только владельца IP, но и срок, в течение которого клиент может использовать его.</span></li></ul><p style="text-align: center;"><img src="https://drive.google.com/uc?export=view&amp;id=1BK50gOzxps3HR1hI2o70B_ojRoYK5lHw"><b></b></p><p style="text-align: center;"><b>DORA путешественница</b></p><p></p><p><strong><span>Сами же адреса могут быть назначены сервером тремя способами:</span></strong></p><ol start='' ><li><strong><span>Статическое распределение.</span></strong>
<span>Админ задаёт нужные соответствия между адресами IP и MAC вручную на DHCP-сервере.</span></li><li><strong><span>Автоматическое распределение.</span></strong>
<span>Сервер закрепляет IP-адрес из области за каждым клиентом навсегда. Срок аренды не ограничен.</span></li><li><strong><span>Динамическое распределение.</span></strong>
<span>DHCP-сервер назначает адрес из области на определённое время, называемое сроком аренды.</span>
<span>IP-адрес назначается каждому клиенту при подключении к сети и возвращается в пул адресов при освобождении его клиентом.</span></li></ol></div></div>
</body>
</html>